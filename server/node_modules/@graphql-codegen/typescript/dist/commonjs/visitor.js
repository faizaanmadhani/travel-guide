"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const visitor_plugin_common_1 = require("@graphql-codegen/visitor-plugin-common");
const autoBind = require("auto-bind");
const graphql_1 = require("graphql");
const typescript_variables_to_object_1 = require("./typescript-variables-to-object");
const avoid_optionals_1 = require("./avoid-optionals");
class TsVisitor extends visitor_plugin_common_1.BaseTypesVisitor {
    constructor(schema, pluginConfig, additionalConfig = {}) {
        super(schema, pluginConfig, {
            noExport: visitor_plugin_common_1.getConfigValue(pluginConfig.noExport, false),
            avoidOptionals: avoid_optionals_1.normalizeAvoidOptionals(visitor_plugin_common_1.getConfigValue(pluginConfig.avoidOptionals, false)),
            maybeValue: visitor_plugin_common_1.getConfigValue(pluginConfig.maybeValue, 'T | null'),
            constEnums: visitor_plugin_common_1.getConfigValue(pluginConfig.constEnums, false),
            enumsAsTypes: visitor_plugin_common_1.getConfigValue(pluginConfig.enumsAsTypes, false),
            immutableTypes: visitor_plugin_common_1.getConfigValue(pluginConfig.immutableTypes, false),
            ...(additionalConfig || {}),
        });
        autoBind(this);
        const enumNames = Object.values(schema.getTypeMap())
            .map(type => (type instanceof graphql_1.GraphQLEnumType ? type.name : undefined))
            .filter(t => t);
        this.setArgumentsTransformer(new typescript_variables_to_object_1.TypeScriptOperationVariablesToObject(this.scalars, this.convertName, this.config.avoidOptionals.object, this.config.immutableTypes, null, enumNames, pluginConfig.enumPrefix));
        this.setDeclarationBlockConfig({
            enumNameValueSeparator: ' =',
            ignoreExport: this.config.noExport,
        });
    }
    getMaybeValue() {
        return `${this.config.noExport ? '' : 'export '}type Maybe<T> = ${this.config.maybeValue};`;
    }
    clearOptional(str) {
        if (str.startsWith('Maybe')) {
            return str.replace(/Maybe<(.*?)>$/, '$1');
        }
        return str;
    }
    NamedType(node) {
        return `Maybe<${super.NamedType(node)}>`;
    }
    ListType(node) {
        return `Maybe<${super.ListType(node)}>`;
    }
    wrapWithListType(str) {
        return `${this.config.immutableTypes ? 'ReadonlyArray' : 'Array'}<${str}>`;
    }
    NonNullType(node) {
        const baseValue = super.NonNullType(node);
        return this.clearOptional(baseValue);
    }
    FieldDefinition(node, key, parent) {
        const typeString = node.type;
        const originalFieldNode = parent[key];
        const addOptionalSign = !this.config.avoidOptionals.object && originalFieldNode.type.kind !== graphql_1.Kind.NON_NULL_TYPE;
        const comment = visitor_plugin_common_1.transformComment(node.description, 1);
        return comment + visitor_plugin_common_1.indent(`${this.config.immutableTypes ? 'readonly ' : ''}${node.name}${addOptionalSign ? '?' : ''}: ${typeString},`);
    }
    InputValueDefinition(node, key, parent) {
        const originalFieldNode = parent[key];
        const addOptionalSign = !this.config.avoidOptionals.inputValue && originalFieldNode.type.kind !== graphql_1.Kind.NON_NULL_TYPE;
        const comment = visitor_plugin_common_1.transformComment(node.description, 1);
        return comment + visitor_plugin_common_1.indent(`${this.config.immutableTypes ? 'readonly ' : ''}${node.name}${addOptionalSign ? '?' : ''}: ${node.type},`);
    }
    EnumTypeDefinition(node) {
        const enumName = node.name;
        // In case of mapped external enum string
        if (this.config.enumValues[enumName] && this.config.enumValues[enumName].sourceFile) {
            return `export { ${this.config.enumValues[enumName].typeIdentifier} };\n`;
        }
        const enumTypeName = this.convertName(node, { useTypesPrefix: this.config.enumPrefix });
        if (this.config.enumsAsTypes) {
            return new visitor_plugin_common_1.DeclarationBlock(this._declarationBlockConfig)
                .export()
                .asKind('type')
                .withComment(node.description)
                .withName(enumTypeName)
                .withContent('\n' +
                node.values
                    .map(enumOption => {
                    let enumValue = enumOption.name;
                    const comment = visitor_plugin_common_1.transformComment(enumOption.description, 1);
                    if (this.config.enumValues[enumName] && this.config.enumValues[enumName].mappedValues && this.config.enumValues[enumName].mappedValues[enumValue]) {
                        enumValue = this.config.enumValues[enumName].mappedValues[enumValue];
                    }
                    return comment + visitor_plugin_common_1.indent(visitor_plugin_common_1.wrapWithSingleQuotes(enumValue));
                })
                    .join(' |\n')).string;
        }
        else {
            return new visitor_plugin_common_1.DeclarationBlock(this._declarationBlockConfig)
                .export()
                .asKind(this.config.constEnums ? 'const enum' : 'enum')
                .withName(enumTypeName)
                .withComment(node.description)
                .withBlock(this.buildEnumValuesBlock(enumName, node.values)).string;
        }
    }
}
exports.TsVisitor = TsVisitor;
//# sourceMappingURL=visitor.js.map