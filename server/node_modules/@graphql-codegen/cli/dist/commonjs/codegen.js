"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@graphql-codegen/core");
const Listr = require("listr");
const plugin_helpers_1 = require("@graphql-codegen/plugin-helpers");
const listr_renderer_1 = require("./utils/listr-renderer");
const load_1 = require("./load");
const graphql_1 = require("graphql");
const plugins_1 = require("./plugins");
const presets_1 = require("./presets");
const debugging_1 = require("./utils/debugging");
const try_to_build_schema_1 = require("./utils/try-to-build-schema");
exports.defaultLoader = (mod) => Promise.resolve().then(() => require(mod));
async function executeCodegen(config) {
    function wrapTask(task, source) {
        return async () => {
            try {
                await Promise.resolve(task());
            }
            catch (error) {
                if (source && !(error instanceof graphql_1.GraphQLError)) {
                    error.source = source;
                }
                throw error;
            }
        };
    }
    const result = [];
    const commonListrOptions = {
        exitOnError: true,
    };
    let listr;
    if (process.env.VERBOSE) {
        listr = new Listr({
            ...commonListrOptions,
            renderer: 'verbose',
            nonTTYRenderer: 'verbose',
        });
    }
    else if (process.env.NODE_ENV === 'test') {
        listr = new Listr({
            ...commonListrOptions,
            renderer: 'silent',
            nonTTYRenderer: 'silent',
        });
    }
    else {
        listr = new Listr({
            ...commonListrOptions,
            renderer: config.silent ? 'silent' : listr_renderer_1.Renderer,
            nonTTYRenderer: config.silent ? 'silent' : 'default',
            collapse: true,
            clearOutput: false,
        });
    }
    let rootConfig = {};
    let rootSchemas;
    let rootDocuments;
    let generates = {};
    async function normalize() {
        /* Load Require extensions */
        const requireExtensions = plugin_helpers_1.normalizeInstanceOrArray(config.require);
        for (const mod of requireExtensions) {
            await Promise.resolve().then(() => require(mod));
        }
        /* Root templates-config */
        rootConfig = config.config || {};
        /* Normalize root "schema" field */
        rootSchemas = plugin_helpers_1.normalizeInstanceOrArray(config.schema);
        /* Normalize root "documents" field */
        rootDocuments = plugin_helpers_1.normalizeInstanceOrArray(config.documents);
        /* Normalize "generators" field */
        const generateKeys = Object.keys(config.generates);
        if (generateKeys.length === 0) {
            throw new core_1.DetailedError('Invalid Codegen Configuration!', `
        Please make sure that your codegen config file contains the "generates" field, with a specification for the plugins you need.
        
        It should looks like that:

        schema:
          - my-schema.graphql
        generates:
          my-file.ts:
            - plugin1
            - plugin2
            - plugin3
        `);
        }
        for (const filename of generateKeys) {
            generates[filename] = plugin_helpers_1.normalizeOutputParam(config.generates[filename]);
            if (generates[filename].plugins.length === 0) {
                throw new core_1.DetailedError('Invalid Codegen Configuration!', `
          Please make sure that your codegen config file has defined plugins list for output "${filename}".
          
          It should looks like that:
  
          schema:
            - my-schema.graphql
          generates:
            my-file.ts:
              - plugin1
              - plugin2
              - plugin3
          `);
            }
        }
        if (rootSchemas.length === 0 && Object.keys(generates).some(filename => !generates[filename].schema || generates[filename].schema.length === 0)) {
            throw new core_1.DetailedError('Invalid Codegen Configuration!', `
        Please make sure that your codegen config file contains either the "schema" field 
        or every generated file has its own "schema" field.
        
        It should looks like that:
        schema:
          - my-schema.graphql

        or:
        generates:
          path/to/output:
            schema: my-schema.graphql
      `);
        }
    }
    listr.add({
        title: 'Parse configuration',
        task: () => normalize(),
    });
    listr.add({
        title: 'Generate outputs',
        task: () => {
            return new Listr(Object.keys(generates).map((filename, i) => {
                const outputConfig = generates[filename];
                const hasPreset = !!outputConfig.preset;
                return {
                    title: hasPreset ? `Generate to ${filename} (using EXPERIMENTAL preset "${outputConfig.preset}")` : `Generate ${filename}`,
                    task: () => {
                        const outputFileTemplateConfig = outputConfig.config || {};
                        const outputDocuments = [];
                        let outputSchema;
                        const outputSpecificSchemas = plugin_helpers_1.normalizeInstanceOrArray(outputConfig.schema);
                        const outputSpecificDocuments = plugin_helpers_1.normalizeInstanceOrArray(outputConfig.documents);
                        return new Listr([
                            {
                                title: 'Load GraphQL schemas',
                                task: wrapTask(async () => {
                                    debugging_1.debugLog(`[CLI] Loading Schemas`);
                                    const allSchemas = [...rootSchemas.map(pointToScehma => load_1.loadSchema(pointToScehma, config)), ...outputSpecificSchemas.map(pointToScehma => load_1.loadSchema(pointToScehma, config))];
                                    if (allSchemas.length > 0) {
                                        outputSchema = await core_1.mergeSchemas(await Promise.all(allSchemas));
                                    }
                                }, filename),
                            },
                            {
                                title: 'Load GraphQL documents',
                                task: wrapTask(async () => {
                                    debugging_1.debugLog(`[CLI] Loading Documents`);
                                    const allDocuments = [...rootDocuments, ...outputSpecificDocuments];
                                    const documents = await load_1.loadDocuments(allDocuments, config);
                                    if (documents.length > 0) {
                                        outputDocuments.push(...documents);
                                    }
                                }, filename),
                            },
                            {
                                title: 'Generate',
                                task: wrapTask(async () => {
                                    debugging_1.debugLog(`[CLI] Generating output`);
                                    const normalizedPluginsArray = plugin_helpers_1.normalizeConfig(outputConfig.plugins);
                                    const pluginLoader = config.pluginLoader || exports.defaultLoader;
                                    const pluginPackages = await Promise.all(normalizedPluginsArray.map(plugin => plugins_1.getPluginByName(Object.keys(plugin)[0], pluginLoader)));
                                    const pluginMap = {};
                                    const preset = hasPreset ? (typeof outputConfig.preset === 'string' ? await presets_1.getPresetByName(outputConfig.preset, exports.defaultLoader) : outputConfig.preset) : null;
                                    pluginPackages.forEach((pluginPackage, i) => {
                                        const plugin = normalizedPluginsArray[i];
                                        const name = Object.keys(plugin)[0];
                                        pluginMap[name] = pluginPackage;
                                    });
                                    const mergedConfig = {
                                        ...rootConfig,
                                        ...(typeof outputFileTemplateConfig === 'string' ? { value: outputFileTemplateConfig } : outputFileTemplateConfig),
                                    };
                                    let outputs = [];
                                    const builtSchema = try_to_build_schema_1.tryToBuildSchema(outputSchema);
                                    if (hasPreset) {
                                        outputs = await preset.buildGeneratesSection({
                                            baseOutputDir: filename,
                                            presetConfig: outputConfig.presetConfig || {},
                                            plugins: normalizedPluginsArray,
                                            schema: outputSchema,
                                            schemaAst: builtSchema,
                                            documents: outputDocuments,
                                            config: mergedConfig,
                                            pluginMap,
                                        });
                                    }
                                    else {
                                        outputs = [
                                            {
                                                filename,
                                                plugins: normalizedPluginsArray,
                                                schema: outputSchema,
                                                schemaAst: builtSchema,
                                                documents: outputDocuments,
                                                config: mergedConfig,
                                                pluginMap,
                                            },
                                        ];
                                    }
                                    const process = async (outputArgs) => {
                                        const output = await core_1.codegen(outputArgs);
                                        result.push({
                                            filename: outputArgs.filename,
                                            content: output,
                                            hooks: outputConfig.hooks || {},
                                        });
                                    };
                                    await Promise.all(outputs.map(process));
                                }, filename),
                            },
                        ], {
                            // it stops when one of tasks failed
                            exitOnError: true,
                        });
                    },
                };
            }), {
                // it doesn't stop when one of tasks failed, to finish at least some of outputs
                exitOnError: false,
                // run 4 at once
                concurrent: 4,
            });
        },
    });
    await listr.run();
    return result;
}
exports.executeCodegen = executeCodegen;
//# sourceMappingURL=codegen.js.map