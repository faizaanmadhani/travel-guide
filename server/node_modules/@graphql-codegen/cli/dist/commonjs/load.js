"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_toolkit_1 = require("graphql-toolkit");
const graphql_1 = require("graphql");
const core_1 = require("@graphql-codegen/core");
const path_1 = require("path");
async function getCustomLoaderByPath(path) {
    const requiredModule = await Promise.resolve().then(() => require(path_1.join(process.cwd(), path)));
    if (requiredModule && requiredModule.default && typeof requiredModule.default === 'function') {
        return requiredModule.default;
    }
    if (requiredModule && typeof requiredModule === 'function') {
        return requiredModule;
    }
    return null;
}
exports.loadSchema = async (schemaDef, config) => {
    if (typeof schemaDef === 'object' && schemaDef[Object.keys(schemaDef)[0]] && schemaDef[Object.keys(schemaDef)[0]].loader && typeof schemaDef[Object.keys(schemaDef)[0]].loader === 'string') {
        const pointToSchema = Object.keys(schemaDef)[0];
        const defObject = schemaDef[pointToSchema];
        const loaderString = defObject.loader;
        try {
            const customSchemaLoader = await getCustomLoaderByPath(loaderString);
            if (customSchemaLoader) {
                const returnedSchema = await customSchemaLoader(pointToSchema, config, defObject);
                if (returnedSchema && isGraphQLSchema(returnedSchema)) {
                    return graphql_toolkit_1.mergeTypeDefs([returnedSchema]);
                }
                else {
                    throw new Error(`Return value of a custom schema loader must be of type "GraphQLSchema"!`);
                }
            }
            else {
                throw new Error(`Unable to find a loader function! Make sure to export a default function from your file`);
            }
        }
        catch (e) {
            throw new core_1.DetailedError('Failed to load custom schema loader', `
        Failed to load schema from ${pointToSchema} using loader "${loaderString}":
    
        ${e.message}
        ${e.stack}
      `, `${pointToSchema} using loader "${loaderString}"`);
        }
    }
    try {
        let pointToSchema = null;
        let options = {};
        if (typeof schemaDef === 'string') {
            pointToSchema = schemaDef;
        }
        else if (typeof schemaDef === 'object') {
            pointToSchema = Object.keys(schemaDef)[0];
            options = schemaDef[pointToSchema];
        }
        if (config.pluckConfig) {
            options.tagPluck = config.pluckConfig;
        }
        if (config.customFetch) {
            const customFetchStr = config.customFetch;
            const [moduleName, fetchFnName] = customFetchStr.split('#');
            options.fetch = await Promise.resolve().then(() => require(moduleName)).then(module => (fetchFnName ? module[fetchFnName] : module));
        }
        const docs = (await graphql_toolkit_1.loadTypedefs(pointToSchema, options)).map(({ content }) => content);
        return graphql_toolkit_1.mergeTypeDefs(docs);
    }
    catch (e) {
        throw new core_1.DetailedError('Failed to load schema', `
        Failed to load schema from ${schemaDef}:

        ${e.message}
        ${e.stack}
    
        GraphQL Code Generator supports:
          - ES Modules and CommonJS exports (export as default or named export "schema")
          - Introspection JSON File
          - URL of GraphQL endpoint
          - Multiple files with type definitions (glob expression)
          - String in config file
    
        Try to use one of above options and run codegen again.
    
      `);
    }
};
exports.loadDocuments = async (documentsDef, config) => {
    const asArray = Array.isArray(documentsDef) ? documentsDef : [documentsDef];
    const loadWithToolkit = [];
    const result = [];
    for (const documentDef of asArray) {
        if (typeof documentDef === 'object' && documentDef[Object.keys(documentDef)[0]] && documentDef[Object.keys(documentDef)[0]].loader && typeof documentDef[Object.keys(documentDef)[0]].loader === 'string') {
            const pointToDoc = Object.keys(documentDef)[0];
            const defObject = documentDef[pointToDoc];
            const loaderString = defObject.loader;
            try {
                const customDocumentLoader = await getCustomLoaderByPath(loaderString);
                if (customDocumentLoader) {
                    const returned = await customDocumentLoader(pointToDoc, config);
                    if (returned && Array.isArray(returned)) {
                        result.push(...returned);
                    }
                    else {
                        throw new Error(`Return value of a custom schema loader must be an Array of: { filePath: string, content: DocumentNode }`);
                    }
                }
                else {
                    throw new Error(`Unable to find a loader function! Make sure to export a default function from your file`);
                }
            }
            catch (e) {
                throw new core_1.DetailedError('Failed to load custom documents loader', `
          Failed to load documents from ${pointToDoc} using loader "${loaderString}":
      
          ${e.message}
        `);
            }
        }
        else if (typeof documentDef === 'string') {
            loadWithToolkit.push(documentDef);
        }
    }
    if (loadWithToolkit.length > 0) {
        const loadDocumentsToolkitConfig = {
            ignore: Object.keys(config.generates).map(p => path_1.join(process.cwd(), p)),
        };
        if (config.pluckConfig) {
            loadDocumentsToolkitConfig.tagPluck = config.pluckConfig;
        }
        const loadedFromToolkit = await graphql_toolkit_1.loadDocuments(loadWithToolkit, loadDocumentsToolkitConfig);
        if (loadedFromToolkit.length > 0) {
            result.push(...loadedFromToolkit.sort((a, b) => {
                if (a.filePath < b.filePath) {
                    return -1;
                }
                if (a.filePath > b.filePath) {
                    return 1;
                }
                return 0;
            }));
        }
    }
    return result;
};
function isGraphQLSchema(schema) {
    const schemaClass = schema.constructor;
    const className = graphql_1.GraphQLSchema.name;
    return className && schemaClass && schemaClass.name === className;
}
//# sourceMappingURL=load.js.map