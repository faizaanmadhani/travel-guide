"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const debugging_1 = require("./utils/debugging");
const child_process_1 = require("child_process");
const path_1 = require("path");
const DEFAULT_HOOKS = {
    afterStart: [],
    beforeDone: [],
    onWatchTriggered: [],
    onError: [],
    afterOneFileWrite: [],
    afterAllFileWrite: [],
    beforeOneFileWrite: [],
    beforeAllFileWrite: [],
};
function normalizeHooks(_hooks) {
    const keys = Object.keys({
        ...DEFAULT_HOOKS,
        ...(_hooks || {}),
    });
    return keys.reduce((prev, hookName) => {
        if (typeof _hooks[hookName] === 'string') {
            return {
                ...prev,
                [hookName]: [_hooks[hookName]],
            };
        }
        else if (Array.isArray(_hooks[hookName])) {
            return {
                ...prev,
                [hookName]: _hooks[hookName],
            };
        }
        else {
            return prev;
        }
    }, {});
}
function execShellCommand(cmd) {
    return new Promise((resolve, reject) => {
        child_process_1.exec(cmd, {
            env: {
                ...process.env,
                PATH: `${process.env.PATH}${path_1.delimiter}${process.cwd()}${path_1.sep}node_modules${path_1.sep}.bin`,
            },
        }, (error, stdout, stderr) => {
            if (error) {
                reject(error);
            }
            else {
                resolve(stdout ? stdout : stderr);
            }
        });
    });
}
async function executeHooks(hookName, scripts = [], args = []) {
    debugging_1.debugLog(`Running lifecycle hook "${hookName}" scripts...`);
    for (const script of scripts) {
        debugging_1.debugLog(`Running lifecycle hook "${hookName}" script: ${script} with args: ${args.join(' ')}...`);
        await execShellCommand(`${script} ${args.join(' ')}`);
    }
}
exports.lifecycleHooks = (_hooks = {}) => {
    const hooks = normalizeHooks(_hooks);
    return {
        afterStart: async () => executeHooks('afterStart', hooks.afterStart),
        onWatchTriggered: async (event, path) => executeHooks('onWatchTriggered', hooks.onWatchTriggered, [event, path]),
        onError: async (error) => executeHooks('onError', hooks.onError, [`"${error}"`]),
        afterOneFileWrite: async (path) => executeHooks('afterOneFileWrite', hooks.afterOneFileWrite, [path]),
        afterAllFileWrite: async (paths) => executeHooks('afterAllFileWrite', hooks.afterAllFileWrite, paths),
        beforeOneFileWrite: async (path) => executeHooks('beforeOneFileWrite', hooks.beforeOneFileWrite, [path]),
        beforeAllFileWrite: async (paths) => executeHooks('beforeAllFileWrite', hooks.beforeAllFileWrite, paths),
        beforeDone: async () => executeHooks('beforeDone', hooks.beforeDone),
    };
};
//# sourceMappingURL=hooks.js.map