"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const core_1 = require("@graphql-codegen/core");
const yml_1 = require("./yml");
const commander_1 = require("commander");
function getCustomConfigPath(cliFlags) {
    const configFile = cliFlags.config;
    if (configFile) {
        const configPath = path_1.resolve(process.cwd(), configFile);
        if (!fs_1.existsSync(configPath)) {
            throw new core_1.DetailedError(`Config ${configPath} does not exist`, `
        Config ${configPath} does not exist.

          $ graphql-codegen --config ${configPath}

        Please make sure the --config points to a correct file.
      `);
        }
        return configPath;
    }
    return null;
}
function loadAndParseConfig(filepath) {
    const ext = filepath.substr(filepath.lastIndexOf('.') + 1);
    switch (ext) {
        case 'yml':
            return yml_1.parseConfigFile(fs_1.readFileSync(filepath, 'utf-8'));
        case 'json':
            return JSON.parse(fs_1.readFileSync(filepath, 'utf-8'));
        case 'js':
            return require(path_1.resolve(process.cwd(), filepath));
        default:
            throw new core_1.DetailedError(`Extension '${ext}' is not supported`, `
        Config ${filepath} couldn't be parsed. Extension '${ext}' is not supported.
      `);
    }
}
exports.loadAndParseConfig = loadAndParseConfig;
function collect(val, memo) {
    memo.push(val);
    return memo;
}
function parseArgv(argv = process.argv) {
    return new commander_1.Command()
        .usage('graphql-codegen [options]')
        .allowUnknownOption(true)
        .option('-c, --config <path>', 'Path to GraphQL codegen YAML config file, defaults to "codegen.yml" on the current directory')
        .option('-w, --watch', 'Watch for changes and execute generation automatically')
        .option('-s, --silent', 'A flag to not print errors in case they occur')
        .option('-r, --require [value]', 'Loads specific require.extensions before running the codegen and reading the configuration', collect, [])
        .option('-o, --overwrite', 'Overwrites existing files')
        .parse(argv);
}
exports.parseArgv = parseArgv;
async function createConfig(cliFlags = parseArgv(process.argv)) {
    const customConfigPath = getCustomConfigPath(cliFlags);
    const locations = [path_1.join(process.cwd(), './codegen.yml'), path_1.join(process.cwd(), './codegen.json')];
    if (customConfigPath) {
        locations.unshift(customConfigPath);
    }
    const filepath = locations.find(fs_1.existsSync);
    if (!filepath) {
        throw new core_1.DetailedError(`Unable to find Codegen config file!`, `
        Please make sure that you have a configuration file under the current directory! 
      `);
    }
    if (cliFlags.require && cliFlags.require.length > 0) {
        for (const mod of cliFlags.require) {
            await Promise.resolve().then(() => require(mod));
        }
    }
    const parsedConfigFile = loadAndParseConfig(filepath);
    parsedConfigFile.configFilePath = filepath;
    if (cliFlags.watch === true) {
        parsedConfigFile.watch = cliFlags.watch;
    }
    if (cliFlags.overwrite === true) {
        parsedConfigFile.overwrite = cliFlags.overwrite;
    }
    if (cliFlags.silent === true) {
        parsedConfigFile.silent = cliFlags.silent;
    }
    return parsedConfigFile;
}
exports.createConfig = createConfig;
//# sourceMappingURL=config.js.map