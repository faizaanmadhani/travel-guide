"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const hooks_1 = require("./hooks");
const codegen_1 = require("./codegen");
const watcher_1 = require("./utils/watcher");
const file_system_1 = require("./utils/file-system");
const mkdirp_1 = require("mkdirp");
const path_1 = require("path");
const debugging_1 = require("./utils/debugging");
const crypto_1 = require("crypto");
const hash = (content) => crypto_1.createHash('sha1')
    .update(content)
    .digest('base64');
async function generate(config, saveToFile = true) {
    await hooks_1.lifecycleHooks(config.hooks).afterStart();
    let recentOutputHash = new Map();
    async function writeOutput(generationResult) {
        if (!saveToFile) {
            return generationResult;
        }
        await hooks_1.lifecycleHooks(config.hooks).beforeAllFileWrite(generationResult.map(r => r.filename));
        await Promise.all(generationResult.map(async (result) => {
            const exists = file_system_1.fileExists(result.filename);
            if (!shouldOverwrite(config, result.filename) && exists) {
                return;
            }
            const content = result.content || '';
            const currentHash = hash(content);
            let previousHash = recentOutputHash.get(result.filename);
            if (!previousHash && exists) {
                previousHash = hash(file_system_1.readSync(result.filename));
            }
            if (previousHash && currentHash === previousHash) {
                debugging_1.debugLog(`Skipping file (${result.filename}) writing due to indentical hash...`);
                return;
            }
            if (content.length === 0) {
                return;
            }
            recentOutputHash.set(result.filename, currentHash);
            const basedir = path_1.dirname(result.filename);
            await hooks_1.lifecycleHooks(result.hooks).beforeOneFileWrite(result.filename);
            await hooks_1.lifecycleHooks(config.hooks).beforeOneFileWrite(result.filename);
            mkdirp_1.sync(basedir);
            file_system_1.writeSync(result.filename, result.content);
            await hooks_1.lifecycleHooks(result.hooks).afterOneFileWrite(result.filename);
            await hooks_1.lifecycleHooks(config.hooks).afterOneFileWrite(result.filename);
        }));
        await hooks_1.lifecycleHooks(config.hooks).afterAllFileWrite(generationResult.map(r => r.filename));
        return generationResult;
    }
    // watch mode
    if (config.watch) {
        return watcher_1.createWatcher(config, writeOutput);
    }
    const outputFiles = await codegen_1.executeCodegen(config);
    await writeOutput(outputFiles);
    hooks_1.lifecycleHooks(config.hooks).beforeDone();
    return outputFiles;
}
exports.generate = generate;
function shouldOverwrite(config, outputPath) {
    const globalValue = config.overwrite === undefined ? true : !!config.overwrite;
    const outputConfig = config.generates[outputPath];
    if (!outputConfig) {
        debugging_1.debugLog(`Couldn't find a config of ${outputPath}`);
        return globalValue;
    }
    if (isConfiguredOutput(outputConfig) && typeof outputConfig.overwrite === 'boolean') {
        return outputConfig.overwrite;
    }
    return globalValue;
}
function isConfiguredOutput(output) {
    return typeof output.plugins !== 'undefined';
}
//# sourceMappingURL=generate-and-save.js.map