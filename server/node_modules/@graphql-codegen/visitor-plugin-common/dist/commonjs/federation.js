"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const graphql_toolkit_1 = require("graphql-toolkit");
const utils_1 = require("./utils");
// TODO: we need to include that scala
exports.federationSpec = graphql_1.parse(/* GraphQL */ `
  scalar _FieldSet

  directive @external on FIELD_DEFINITION
  directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
  directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
  directive @key(fields: _FieldSet!) on OBJECT | INTERFACE
`);
function addFederationToSchema(schema) {
    const doc = graphql_1.parse(graphql_toolkit_1.printSchemaWithDirectives(schema));
    const visited = graphql_1.visit(doc, {
        ObjectTypeDefinition(node) {
            if (!isFederationObjectType(node)) {
                return node;
            }
            return {
                ...node,
                fields: [
                    {
                        kind: graphql_1.Kind.FIELD_DEFINITION,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: '__resolveReference',
                        },
                        type: {
                            kind: graphql_1.Kind.NAMED_TYPE,
                            name: {
                                kind: graphql_1.Kind.NAME,
                                value: node.name.value,
                            },
                        },
                        arguments: [],
                    },
                    ...node.fields,
                ],
            };
        },
    });
    return graphql_1.buildASTSchema(visited, {
        assumeValidSDL: true,
    });
}
exports.addFederationToSchema = addFederationToSchema;
class ApolloFederation {
    constructor({ enabled, schema }) {
        this.enabled = false;
        this.enabled = enabled;
        this.schema = schema;
        this.providesMap = this.createMapOfProvides();
    }
    filterTypeNames(typeNames) {
        return this.enabled ? typeNames.filter(t => t !== '_FieldSet') : typeNames;
    }
    filterFieldNames(fieldNames) {
        return this.enabled ? fieldNames.filter(t => t !== '__resolveReference') : fieldNames;
    }
    skipDirective(name) {
        return this.enabled && ['external', 'requires', 'provides', 'key'].includes(name);
    }
    skipScalar(name) {
        return this.enabled && name === '_FieldSet';
    }
    skipField({ fieldNode, parentType }) {
        if (!this.enabled || !graphql_1.isObjectType(parentType) || !isFederationObjectType(parentType)) {
            return false;
        }
        return this.isExternalAndNotProvided(fieldNode, parentType);
    }
    translateParentType({ fieldNode, parentType, parentTypeSignature }) {
        if (this.enabled && graphql_1.isObjectType(parentType) && isFederationObjectType(parentType)) {
            const keys = getDirectivesByName('key', parentType);
            if (keys.length) {
                const outputs = [];
                // Look for @requires and see what the service needs and gets
                const requires = getDirectivesByName('requires', fieldNode)
                    .map(this.extractFieldSet)
                    .reduce((prev, curr) => [...prev, ...curr], [])
                    .map(name => {
                    return { name, required: graphql_1.isNonNullType(parentType.getFields()[name].type) };
                });
                const requiredFields = this.translateFieldSet(requires, parentTypeSignature);
                // @key() @key() - "primary keys" in Federation
                const primaryKeys = keys.map(def => {
                    const fields = this.extractFieldSet(def).map(name => ({ name, required: true }));
                    return this.translateFieldSet(fields, parentTypeSignature);
                });
                const [open, close] = primaryKeys.length > 1 ? ['(', ')'] : ['', ''];
                outputs.push([open, primaryKeys.join(' | '), close].join(''));
                // include required fields
                if (requires.length) {
                    outputs.push(`& ${requiredFields}`);
                }
                return outputs.join(' ');
            }
        }
        return parentTypeSignature;
    }
    isExternalAndNotProvided(fieldNode, objectType) {
        return this.isExternal(fieldNode) && !this.hasProvides(objectType, fieldNode);
    }
    isExternal(node) {
        return getDirectivesByName('external', node).length > 0;
    }
    hasProvides(objectType, node) {
        const fields = this.providesMap[graphql_1.isObjectType(objectType) ? objectType.name : objectType.name.value];
        if (fields && fields.length) {
            return fields.includes(node.name.value);
        }
        return false;
    }
    translateFieldSet(fields, parentTypeRef) {
        // TODO: support other things than fields separated by a whitespace (fields: "fieldA fieldB fieldC")
        const keys = fields.map(field => `'${field.name}'`).join(' | ');
        return `Pick<${parentTypeRef}, ${keys}>`;
    }
    extractFieldSet(directive) {
        const arg = directive.arguments.find(arg => arg.name.value === 'fields');
        const value = arg.value.value;
        if (/[\{\}]+/gi.test(value)) {
            throw new Error('Nested fields in _FieldSet is not supported');
        }
        return deduplicate(value.split(/\s+/g));
    }
    createMapOfProvides() {
        const providesMap = {};
        Object.keys(this.schema.getTypeMap()).forEach(typename => {
            const objectType = this.schema.getType(typename);
            if (graphql_1.isObjectType(objectType)) {
                Object.values(objectType.getFields()).forEach(field => {
                    const provides = getDirectivesByName('provides', field.astNode)
                        .map(this.extractFieldSet)
                        .reduce((prev, curr) => [...prev, ...curr], []);
                    const ofType = utils_1.getBaseType(field.type);
                    if (!providesMap[ofType.name]) {
                        providesMap[ofType.name] = [];
                    }
                    providesMap[ofType.name].push(...provides);
                });
            }
        });
        return providesMap;
    }
}
exports.ApolloFederation = ApolloFederation;
function isFederationObjectType(node) {
    const name = graphql_1.isObjectType(node) ? node.name : node.name.value;
    const directives = graphql_1.isObjectType(node) ? node.astNode.directives : node.directives;
    const isNotRoot = !['Query', 'Mutation', 'Subscription'].includes(name);
    const isNotIntrospection = !name.startsWith('__');
    const hasKeyDirective = directives.some(d => d.name.value === 'key');
    return isNotRoot && isNotIntrospection && hasKeyDirective;
}
function deduplicate(items) {
    return items.filter((item, i) => items.indexOf(item) === i);
}
function getDirectivesByName(name, node) {
    let astNode;
    if (graphql_1.isObjectType(node)) {
        astNode = node.astNode;
    }
    else {
        astNode = node;
    }
    if (astNode && astNode.directives) {
        return astNode.directives.filter(d => d.name.value === name);
    }
    return [];
}
//# sourceMappingURL=federation.js.map