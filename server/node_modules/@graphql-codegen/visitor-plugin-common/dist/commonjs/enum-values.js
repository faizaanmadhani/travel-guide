"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const core_1 = require("@graphql-codegen/core");
const mappers_1 = require("./mappers");
function parseEnumValues(schema, mapOrStr) {
    const allTypes = schema.getTypeMap();
    const allEnums = Object.keys(allTypes).filter(t => graphql_1.isEnumType(allTypes[t]));
    if (typeof mapOrStr === 'object') {
        const invalidMappings = Object.keys(mapOrStr).filter(gqlName => !allEnums.includes(gqlName));
        if (invalidMappings.length > 0) {
            throw new core_1.DetailedError(`Invalid 'enumValues' mapping!`, `The following types does not exist in your GraphQL schema: ${invalidMappings.join(', ')}`);
        }
        return Object.keys(mapOrStr).reduce((prev, gqlIdentifier) => {
            const pointer = mapOrStr[gqlIdentifier];
            if (typeof pointer === 'string') {
                const mapper = mappers_1.parseMapper(pointer, gqlIdentifier);
                return {
                    ...prev,
                    [gqlIdentifier]: {
                        typeIdentifier: gqlIdentifier,
                        sourceFile: mapper.isExternal ? mapper.source : undefined,
                        sourceIdentifier: mapper.type,
                        mappedValues: null,
                    },
                };
            }
            else if (typeof pointer === 'object') {
                return {
                    ...prev,
                    [gqlIdentifier]: {
                        typeIdentifier: gqlIdentifier,
                        sourceFile: null,
                        sourceIdentifier: null,
                        mappedValues: pointer,
                    },
                };
            }
            else {
                throw new core_1.DetailedError(`Invalid "enumValues" configuration`, `Enum "${gqlIdentifier}": expected string or object (with enum values mapping)`);
            }
        }, {});
    }
    else if (typeof mapOrStr === 'string') {
        return allEnums
            .filter(enumName => !enumName.startsWith('__'))
            .reduce((prev, enumName) => {
            return {
                ...prev,
                [enumName]: {
                    typeIdentifier: enumName,
                    sourceFile: mapOrStr,
                    sourceIdentifier: enumName,
                    mappedValues: null,
                },
            };
        }, {});
    }
    return {};
}
exports.parseEnumValues = parseEnumValues;
//# sourceMappingURL=enum-values.js.map