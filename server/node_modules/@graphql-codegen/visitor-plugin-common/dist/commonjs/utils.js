"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const change_case_1 = require("change-case");
const graphql_1 = require("graphql");
const scalars_1 = require("./scalars");
const mappers_1 = require("./mappers");
function isWrapperType(t) {
    return graphql_1.isListType(t) || graphql_1.isNonNullType(t);
}
exports.getConfigValue = (value, defaultValue) => {
    if (value === null || value === undefined) {
        return defaultValue;
    }
    return value;
};
function getBaseType(type) {
    if (isWrapperType(type)) {
        return getBaseType(type.ofType);
    }
    else {
        return type;
    }
}
exports.getBaseType = getBaseType;
function quoteIfNeeded(array, joinWith = ' & ') {
    if (array.length === 0) {
        return '';
    }
    else if (array.length === 1) {
        return array[0];
    }
    else {
        return `(${array.join(joinWith)})`;
    }
}
exports.quoteIfNeeded = quoteIfNeeded;
function block(array) {
    return array && array.length !== 0 ? '{\n' + array.join('\n') + '\n}' : '';
}
exports.block = block;
function wrapWithSingleQuotes(str) {
    return `'${str}'`;
}
exports.wrapWithSingleQuotes = wrapWithSingleQuotes;
function breakLine(str) {
    return str + '\n';
}
exports.breakLine = breakLine;
function indent(str, count = 1) {
    return new Array(count).fill('  ').join('') + str;
}
exports.indent = indent;
function indentMultiline(str, count = 1) {
    const indentation = new Array(count).fill('  ').join('');
    const replaceWith = '\n' + indentation;
    return indentation + str.replace(/\n/g, replaceWith);
}
exports.indentMultiline = indentMultiline;
function transformComment(comment, indentLevel = 0) {
    if (!comment || comment === '') {
        return '';
    }
    if (isStringValueNode(comment)) {
        comment = comment.value;
    }
    const lines = comment.split('\n');
    return lines
        .map((line, index) => {
        const isLast = lines.length === index + 1;
        const isFirst = index === 0;
        if (isFirst && isLast) {
            return indent(`/** ${comment} */\n`, indentLevel);
        }
        return indent(`${isFirst ? '/** \n' : ''} * ${line}${isLast ? '\n **/\n' : ''}`, indentLevel);
    })
        .join('\n');
}
exports.transformComment = transformComment;
class DeclarationBlock {
    constructor(_config) {
        this._config = _config;
        this._decorator = null;
        this._export = false;
        this._name = null;
        this._kind = null;
        this._methodName = null;
        this._content = null;
        this._block = null;
        this._nameGenerics = null;
        this._comment = null;
        this._ignoreBlockWrapper = false;
        this._config = {
            blockWrapper: '',
            blockTransformer: block => block,
            enumNameValueSeparator: ':',
            ...this._config,
        };
    }
    withDecorator(decorator) {
        this._decorator = decorator;
        return this;
    }
    export(exp = true) {
        if (!this._config.ignoreExport) {
            this._export = exp;
        }
        return this;
    }
    asKind(kind) {
        this._kind = kind;
        return this;
    }
    withComment(comment) {
        if (comment) {
            this._comment = transformComment(comment, 0);
        }
        return this;
    }
    withMethodCall(methodName, ignoreBlockWrapper = false) {
        this._methodName = methodName;
        this._ignoreBlockWrapper = ignoreBlockWrapper;
        return this;
    }
    withBlock(block) {
        this._block = block;
        return this;
    }
    withContent(content) {
        this._content = content;
        return this;
    }
    withName(name, generics = null) {
        this._name = name;
        this._nameGenerics = generics;
        return this;
    }
    get string() {
        let result = '';
        if (this._decorator) {
            result += this._decorator + '\n';
        }
        if (this._export) {
            result += 'export ';
        }
        if (this._kind) {
            let extra = '';
            let name = '';
            if (['type', 'const', 'var', 'let'].includes(this._kind)) {
                extra = '= ';
            }
            if (this._name) {
                name = this._name + (this._nameGenerics || '') + ' ';
            }
            result += this._kind + ' ' + name + extra;
        }
        if (this._block) {
            if (this._content) {
                result += this._content;
            }
            const blockWrapper = this._ignoreBlockWrapper ? '' : this._config.blockWrapper;
            const before = '{' + blockWrapper;
            const after = blockWrapper + '}';
            const block = [before, this._block, after].filter(val => !!val).join('\n');
            if (this._methodName) {
                result += `${this._methodName}(${this._config.blockTransformer(block)})`;
            }
            else {
                result += this._config.blockTransformer(block);
            }
        }
        else if (this._content) {
            result += this._content;
        }
        else if (this._kind) {
            result += '{}';
        }
        return (this._comment ? this._comment : '') + result + (this._kind === 'interface' || this._kind === 'enum' || this._kind === 'namespace' ? '' : ';') + '\n';
    }
}
exports.DeclarationBlock = DeclarationBlock;
function getBaseTypeNode(typeNode) {
    if (typeNode.kind === graphql_1.Kind.LIST_TYPE || typeNode.kind === graphql_1.Kind.NON_NULL_TYPE) {
        return getBaseTypeNode(typeNode.type);
    }
    return typeNode;
}
exports.getBaseTypeNode = getBaseTypeNode;
function convertNameParts(str, func, removeUnderscore = false) {
    if (removeUnderscore) {
        return func(str);
    }
    return str
        .split('_')
        .map(s => func(s))
        .join('_');
}
exports.convertNameParts = convertNameParts;
function toPascalCase(str, transformUnderscore = false) {
    return convertNameParts(str, change_case_1.pascalCase, transformUnderscore);
}
exports.toPascalCase = toPascalCase;
function buildScalars(schema, scalarsMapping, defaultScalarsMapping = scalars_1.DEFAULT_SCALARS) {
    let result = {};
    Object.keys(defaultScalarsMapping).forEach(name => {
        result[name] = mappers_1.parseMapper(defaultScalarsMapping[name]);
    });
    if (schema) {
        const typeMap = schema.getTypeMap();
        Object.keys(typeMap)
            .map(typeName => typeMap[typeName])
            .filter(type => graphql_1.isScalarType(type))
            .map((scalarType) => {
            const name = scalarType.name;
            if (typeof scalarsMapping === 'string') {
                const value = mappers_1.parseMapper(scalarsMapping + '#' + name, name);
                result[name] = value;
            }
            else if (scalarsMapping && typeof scalarsMapping[name] === 'string') {
                const value = mappers_1.parseMapper(scalarsMapping[name], name);
                result[name] = value;
            }
            else if (scalarsMapping && scalarsMapping[name]) {
                result[name] = {
                    isExternal: false,
                    type: JSON.stringify(scalarsMapping[name]),
                };
            }
            else if (!defaultScalarsMapping[name]) {
                result[name] = {
                    isExternal: false,
                    type: 'any',
                };
            }
        });
    }
    else if (scalarsMapping) {
        if (typeof scalarsMapping === 'string') {
            throw new Error('Cannot use string scalars mapping when building without a schema');
        }
        Object.keys(scalarsMapping).forEach(name => {
            if (typeof scalarsMapping[name] === 'string') {
                const value = mappers_1.parseMapper(scalarsMapping[name], name);
                result[name] = value;
            }
            else {
                result[name] = {
                    isExternal: false,
                    type: JSON.stringify(scalarsMapping[name]),
                };
            }
        });
    }
    return result;
}
exports.buildScalars = buildScalars;
function isStringValueNode(node) {
    return node && typeof node === 'object' && node.kind === 'StringValue';
}
function isRootType(type, schema) {
    return graphql_1.isEqualType(type, schema.getQueryType()) || graphql_1.isEqualType(type, schema.getMutationType()) || graphql_1.isEqualType(type, schema.getSubscriptionType());
}
exports.isRootType = isRootType;
function getRootTypeNames(schema) {
    return [schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()].filter(t => t).map(t => t.name);
}
exports.getRootTypeNames = getRootTypeNames;
function stripMapperTypeInterpolation(identifier) {
    return identifier.trim().replace(/[^$\w].*$/, '');
}
exports.stripMapperTypeInterpolation = stripMapperTypeInterpolation;
exports.OMIT_TYPE = 'export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;';
exports.REQUIRE_FIELDS_TYPE = `export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };`;
//# sourceMappingURL=utils.js.map