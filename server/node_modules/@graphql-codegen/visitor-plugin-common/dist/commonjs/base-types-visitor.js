"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const base_visitor_1 = require("./base-visitor");
const scalars_1 = require("./scalars");
const declaration_kinds_1 = require("./declaration-kinds");
const utils_1 = require("./utils");
const variables_to_object_1 = require("./variables-to-object");
const enum_values_1 = require("./enum-values");
class BaseTypesVisitor extends base_visitor_1.BaseVisitor {
    constructor(_schema, rawConfig, additionalConfig, defaultScalars = scalars_1.DEFAULT_SCALARS) {
        super(rawConfig, {
            enumPrefix: utils_1.getConfigValue(rawConfig.enumPrefix, true),
            addUnderscoreToArgsType: utils_1.getConfigValue(rawConfig.addUnderscoreToArgsType, false),
            enumValues: enum_values_1.parseEnumValues(_schema, rawConfig.enumValues),
            declarationKind: declaration_kinds_1.normalizeDeclarationKind(rawConfig.declarationKind),
            scalars: utils_1.buildScalars(_schema, rawConfig.scalars, defaultScalars),
            ...additionalConfig,
        });
        this._schema = _schema;
        this._argumentsTransformer = new variables_to_object_1.OperationVariablesToObject(this.scalars, this.convertName);
    }
    getScalarsImports() {
        return Object.keys(this.config.scalars)
            .map(enumName => {
            const mappedValue = this.config.scalars[enumName];
            if (mappedValue.isExternal) {
                return this._buildTypeImport(mappedValue.import, mappedValue.source, mappedValue.default);
            }
            return null;
        })
            .filter(a => a);
    }
    get scalarsDefinition() {
        const allScalars = Object.keys(this.config.scalars).map(scalarName => {
            const scalarValue = this.config.scalars[scalarName].type;
            const scalarType = this._schema.getType(scalarName);
            const comment = scalarType && scalarType.astNode && scalarType.description ? utils_1.transformComment(scalarType.description, 1) : '';
            return comment + utils_1.indent(`${scalarName}: ${scalarValue},`);
        });
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind(this._parsedConfig.declarationKind.scalar)
            .withName('Scalars')
            .withComment('All built-in and custom scalars, mapped to their actual values')
            .withBlock(allScalars.join('\n')).string;
    }
    setDeclarationBlockConfig(config) {
        this._declarationBlockConfig = config;
    }
    setArgumentsTransformer(argumentsTransfomer) {
        this._argumentsTransformer = argumentsTransfomer;
    }
    NonNullType(node) {
        const asString = node.type;
        return asString;
    }
    getInputObjectDeclarationBlock(node) {
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind(this._parsedConfig.declarationKind.input)
            .withName(this.convertName(node))
            .withComment(node.description)
            .withBlock(node.fields.join('\n'));
    }
    InputObjectTypeDefinition(node) {
        return this.getInputObjectDeclarationBlock(node).string;
    }
    InputValueDefinition(node) {
        const comment = utils_1.transformComment(node.description, 1);
        return comment + utils_1.indent(`${node.name}: ${node.type},`);
    }
    Name(node) {
        return node.value;
    }
    FieldDefinition(node) {
        const typeString = node.type;
        const comment = utils_1.transformComment(node.description, 1);
        return comment + utils_1.indent(`${node.name}: ${typeString},`);
    }
    UnionTypeDefinition(node, key, parent) {
        const originalNode = parent[key];
        const possibleTypes = originalNode.types.map(t => (this.scalars[t.name.value] ? this._getScalar(t.name.value) : this.convertName(t))).join(' | ');
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName(node))
            .withComment(node.description)
            .withContent(possibleTypes).string;
    }
    getObjectTypeDeclarationBlock(node, originalNode) {
        const optionalTypename = this.config.nonOptionalTypename ? '__typename' : '__typename?';
        const { type } = this._parsedConfig.declarationKind;
        const allFields = [...(this.config.addTypename ? [utils_1.indent(`${this.config['immutableTypes'] ? 'readonly' : ''} ${optionalTypename}: '${node.name}'${type === 'class' ? ';' : ','}`)] : []), ...node.fields];
        const buildInterfaces = () => {
            if (!originalNode.interfaces || !node.interfaces.length) {
                return '';
            }
            const interfaces = originalNode.interfaces.map(i => this.convertName(i));
            if (type === 'interface' || type === 'class') {
                return ' extends ' + interfaces.join(', ') + (allFields.length ? ' ' : ' {}');
            }
            return interfaces.join(' & ') + (allFields.length ? ' & ' : '');
        };
        const interfaces = buildInterfaces();
        let declarationBlock = new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind(type)
            .withName(this.convertName(node))
            .withContent(interfaces)
            .withComment(node.description);
        return declarationBlock.withBlock(allFields.join('\n'));
    }
    ObjectTypeDefinition(node, key, parent) {
        const originalNode = parent[key];
        return [this.getObjectTypeDeclarationBlock(node, originalNode).string, this.buildArgumentsBlock(originalNode)].filter(f => f).join('\n\n');
    }
    getInterfaceTypeDeclarationBlock(node, originalNode) {
        const argumentsBlock = this.buildArgumentsBlock(originalNode);
        let declarationBlock = new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind(this._parsedConfig.declarationKind.interface)
            .withName(this.convertName(node))
            .withComment(node.description);
        return declarationBlock.withBlock(node.fields.join('\n'));
    }
    InterfaceTypeDefinition(node, key, parent) {
        const originalNode = parent[key];
        return [this.getInterfaceTypeDeclarationBlock(node, originalNode).string, this.buildArgumentsBlock(originalNode)].filter(f => f).join('\n\n');
    }
    ScalarTypeDefinition(node) {
        // We empty this because we handle scalars in a different way, see constructor.
        return '';
    }
    _buildTypeImport(identifier, source, asDefault = false) {
        if (asDefault) {
            return `import ${identifier} from '${source}';`;
        }
        return `import { ${identifier} } from '${source}';`;
    }
    getEnumsImports() {
        return Object.keys(this.config.enumValues)
            .map(enumName => {
            const mappedValue = this.config.enumValues[enumName];
            if (mappedValue.sourceFile) {
                if (mappedValue.sourceIdentifier === 'default') {
                    return this._buildTypeImport(mappedValue.typeIdentifier, mappedValue.sourceFile, true);
                }
                const identifier = mappedValue.sourceIdentifier !== mappedValue.typeIdentifier ? `${mappedValue.sourceIdentifier} as ${mappedValue.typeIdentifier}` : mappedValue.sourceIdentifier;
                return this._buildTypeImport(identifier, mappedValue.sourceFile);
            }
            return null;
        })
            .filter(a => a);
    }
    EnumTypeDefinition(node) {
        const enumName = node.name;
        // In case of mapped external enum string
        if (this.config.enumValues[enumName] && this.config.enumValues[enumName].sourceFile) {
            return null;
        }
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('enum')
            .withName(this.convertName(node, { useTypesPrefix: this.config.enumPrefix }))
            .withComment(node.description)
            .withBlock(this.buildEnumValuesBlock(enumName, node.values)).string;
    }
    // We are using it in order to transform "description" field
    StringValue(node) {
        return node.value;
    }
    buildEnumValuesBlock(typeName, values) {
        return values
            .map(enumOption => {
            const optionName = this.convertName(enumOption, { useTypesPrefix: false, transformUnderscore: true });
            const comment = utils_1.transformComment(enumOption.description, 1);
            let enumValue = enumOption.name;
            if (this.config.enumValues[typeName] && this.config.enumValues[typeName].mappedValues && this.config.enumValues[typeName].mappedValues[enumValue]) {
                enumValue = this.config.enumValues[typeName].mappedValues[enumValue];
            }
            return comment + utils_1.indent(`${optionName}${this._declarationBlockConfig.enumNameValueSeparator} ${utils_1.wrapWithSingleQuotes(enumValue)}`);
        })
            .join(',\n');
    }
    DirectiveDefinition(node) {
        return '';
    }
    getArgumentsObjectDeclarationBlock(node, name, field) {
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind(this._parsedConfig.declarationKind.arguments)
            .withName(this.convertName(name))
            .withComment(node.description)
            .withBlock(this._argumentsTransformer.transform(field.arguments));
    }
    getArgumentsObjectTypeDefinition(node, name, field) {
        return this.getArgumentsObjectDeclarationBlock(node, name, field).string;
    }
    buildArgumentsBlock(node) {
        const fieldsWithArguments = node.fields.filter(field => field.arguments && field.arguments.length > 0) || [];
        return fieldsWithArguments
            .map(field => {
            const name = node.name.value +
                (this.config.addUnderscoreToArgsType ? '_' : '') +
                this.convertName(field, {
                    useTypesPrefix: false,
                }) +
                'Args';
            return this.getArgumentsObjectTypeDefinition(node, name, field);
        })
            .join('\n\n');
    }
    _getScalar(name) {
        return `Scalars['${name}']`;
    }
    _getTypeForNode(node) {
        const typeAsString = node.name;
        if (this.scalars[typeAsString]) {
            return this._getScalar(typeAsString);
        }
        else if (this.config.enumValues[typeAsString]) {
            return this.config.enumValues[typeAsString].typeIdentifier;
        }
        const schemaType = this._schema.getType(node.name);
        if (schemaType && graphql_1.isEnumType(schemaType)) {
            return this.convertName(node, { useTypesPrefix: this.config.enumPrefix });
        }
        return this.convertName(node);
    }
    NamedType(node) {
        return this._getTypeForNode(node);
    }
    ListType(node) {
        const asString = node.type;
        return this.wrapWithListType(asString);
    }
    SchemaDefinition() {
        return null;
    }
    wrapWithListType(str) {
        return `Array<${str}>`;
    }
}
exports.BaseTypesVisitor = BaseTypesVisitor;
//# sourceMappingURL=base-types-visitor.js.map