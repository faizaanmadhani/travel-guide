import { Kind, isObjectType, isUnionType, isInterfaceType, isEnumType, SchemaMetaFieldDef, TypeMetaFieldDef, isListType, isNonNullType, isAbstractType, } from 'graphql';
import { getBaseType } from './utils';
function isMetadataFieldName(name) {
    return ['__schema', '__type'].includes(name);
}
const metadataFieldMap = {
    __schema: SchemaMetaFieldDef,
    __type: TypeMetaFieldDef,
};
const getFieldNodeNameValue = (node) => {
    return (node.alias || node.name).value;
};
const mergeSelectionSets = (selectionSet1, selectionSet2) => {
    const newSelections = [...selectionSet1.selections];
    for (const selection2 of selectionSet2.selections) {
        if (selection2.kind === 'FragmentSpread') {
            newSelections.push(selection2);
            continue;
        }
        if (selection2.kind !== 'Field') {
            throw new TypeError('Invalid state.');
        }
        const match = newSelections.find(selection1 => selection1.kind === 'Field' && getFieldNodeNameValue(selection1) === getFieldNodeNameValue(selection2));
        if (match) {
            // recursively merge all selection sets
            if (match.kind === 'Field' && match.selectionSet && selection2.selectionSet) {
                mergeSelectionSets(match.selectionSet, selection2.selectionSet);
            }
            continue;
        }
        newSelections.push(selection2);
    }
    // replace existing selections
    selectionSet1.selections = newSelections;
};
export class SelectionSetToObject {
    constructor(_scalars, _schema, _convertName, _addTypename, _preResolveTypes, _nonOptionalTypename, _loadedFragments, _namespacedImportName, _dedupeOperationSuffix, _enumPrefix, _parentSchemaType, _selectionSet) {
        this._scalars = _scalars;
        this._schema = _schema;
        this._convertName = _convertName;
        this._addTypename = _addTypename;
        this._preResolveTypes = _preResolveTypes;
        this._nonOptionalTypename = _nonOptionalTypename;
        this._loadedFragments = _loadedFragments;
        this._namespacedImportName = _namespacedImportName;
        this._dedupeOperationSuffix = _dedupeOperationSuffix;
        this._enumPrefix = _enumPrefix;
        this._parentSchemaType = _parentSchemaType;
        this._selectionSet = _selectionSet;
        this._primitiveFields = [];
        this._primitiveAliasedFields = [];
        this._linksFields = [];
        this._fragments = {};
        this._queriedForTypename = false;
    }
    createNext(parentSchemaType, selectionSet) {
        throw new Error(`You must override createNext in your SelectionSetToObject implementation!`);
    }
    wrapTypeWithModifiers(baseType, type) {
        throw new Error(`You must override wrapTypeWithModifiers in your SelectionSetToObject implementation!`);
    }
    /**
     * traverse the inline fragment nodes recursively for colleting the selectionSets on each type
     */
    _collectInlineFragments(parentType, nodes, types) {
        if (isListType(parentType) || isNonNullType(parentType)) {
            return this._collectInlineFragments(parentType.ofType, nodes, types);
        }
        else if (isObjectType(parentType)) {
            for (const node of nodes) {
                const onType = node.typeCondition.name.value;
                const typeOnSchema = this._schema.getType(onType);
                if (isObjectType(typeOnSchema)) {
                    let typeSelections = types.get(typeOnSchema.name);
                    if (!typeSelections) {
                        typeSelections = [];
                        types.set(typeOnSchema.name, typeSelections);
                    }
                    typeSelections.push(...node.selectionSet.selections.filter(selection => selection.kind !== 'InlineFragment'));
                    this._collectInlineFragments(typeOnSchema, node.selectionSet.selections.filter(selection => selection.kind === 'InlineFragment'), types);
                }
                else if (isInterfaceType(typeOnSchema) && parentType.isTypeOf(typeOnSchema, null, null)) {
                    let typeSelections = types.get(parentType.name);
                    if (!typeSelections) {
                        typeSelections = [];
                        types.set(parentType.name, typeSelections);
                    }
                    typeSelections.push(...node.selectionSet.selections.filter(selection => selection.kind !== 'InlineFragment'));
                    this._collectInlineFragments(typeOnSchema, node.selectionSet.selections.filter(selection => selection.kind === 'InlineFragment'), types);
                }
            }
        }
        else if (isInterfaceType(parentType)) {
            const possibleTypes = this._getPossibleTypes(parentType);
            for (const node of nodes) {
                const onType = node.typeCondition.name.value;
                const schemaType = this._schema.getType(onType);
                if (!schemaType) {
                    throw new Error(`Inline fragment refernces a GraphQL type "${onType}" that does not exists in your schema!`);
                }
                if (isObjectType(schemaType) && possibleTypes.find(possibleType => possibleType.name === schemaType.name)) {
                    let typeSelections = types.get(onType);
                    if (!typeSelections) {
                        typeSelections = [];
                        types.set(schemaType.name, typeSelections);
                    }
                    typeSelections.push(...node.selectionSet.selections.filter(selection => selection.kind !== 'InlineFragment'));
                    this._collectInlineFragments(schemaType, node.selectionSet.selections.filter(selection => selection.kind === 'InlineFragment'), types);
                }
                else if (isInterfaceType(schemaType) && schemaType.name === parentType.name) {
                    for (const possibleType of possibleTypes) {
                        let typeSelections = types.get(possibleType.name);
                        if (!typeSelections) {
                            typeSelections = [];
                            types.set(possibleType.name, typeSelections);
                        }
                        typeSelections.push(...node.selectionSet.selections.filter(selection => selection.kind !== 'InlineFragment'));
                        this._collectInlineFragments(schemaType, node.selectionSet.selections.filter(selection => selection.kind === 'InlineFragment'), types);
                    }
                }
            }
        }
        else if (isUnionType(parentType)) {
            const possibleTypes = parentType.getTypes();
            for (const node of nodes) {
                const onType = node.typeCondition.name.value;
                const schemaType = this._schema.getType(onType);
                if (!schemaType) {
                    throw new Error(`Inline fragment refernces a GraphQL type "${onType}" that does not exists in your schema!`);
                }
                if (isObjectType(schemaType) && possibleTypes.find(possibleType => possibleType.name === schemaType.name)) {
                    let typeSelections = types.get(onType);
                    if (!typeSelections) {
                        typeSelections = [];
                        types.set(onType, typeSelections);
                    }
                    typeSelections.push(...node.selectionSet.selections.filter(selection => selection.kind !== 'InlineFragment'));
                    this._collectInlineFragments(schemaType, node.selectionSet.selections.filter(selection => selection.kind === 'InlineFragment'), types);
                }
                else if (isInterfaceType(schemaType)) {
                    const possibleInterfaceTypes = this._getPossibleTypes(schemaType);
                    for (const possibleType of possibleTypes) {
                        if (possibleInterfaceTypes.find(possibleInterfaceType => possibleInterfaceType.name === possibleType.name)) {
                            let typeSelections = types.get(possibleType.name);
                            if (!typeSelections) {
                                typeSelections = [];
                                types.set(possibleType.name, typeSelections);
                            }
                            typeSelections.push(...node.selectionSet.selections.filter(selection => selection.kind !== 'InlineFragment'));
                            this._collectInlineFragments(schemaType, node.selectionSet.selections.filter(selection => selection.kind === 'InlineFragment'), types);
                        }
                    }
                }
            }
        }
    }
    _getPossibleTypes(type) {
        if (isListType(type) || isNonNullType(type)) {
            return this._getPossibleTypes(type.ofType);
        }
        else if (isObjectType(type)) {
            return [type];
        }
        else if (isAbstractType(type)) {
            return this._schema.getPossibleTypes(type);
        }
        return [];
    }
    _createInlineFragmentForFieldNodes(parentType, fieldNodes) {
        return {
            kind: Kind.INLINE_FRAGMENT,
            typeCondition: {
                kind: Kind.NAMED_TYPE,
                name: {
                    kind: Kind.NAME,
                    value: parentType.name,
                },
            },
            directives: [],
            selectionSet: {
                kind: Kind.SELECTION_SET,
                selections: fieldNodes,
            },
        };
    }
    get string() {
        if (!this._selectionSet || !this._selectionSet.selections || this._selectionSet.selections.length === 0) {
            return '';
        }
        const { selections } = this._selectionSet;
        const inlineFragmentSelections = [];
        const fieldNodes = [];
        const fragmentSpreadNodes = [];
        for (const selection of selections) {
            switch (selection.kind) {
                case Kind.FIELD:
                    fieldNodes.push(selection);
                    break;
                case Kind.FRAGMENT_SPREAD:
                    fragmentSpreadNodes.push(selection);
                    break;
                case Kind.INLINE_FRAGMENT:
                    inlineFragmentSelections.push(selection);
                    break;
            }
        }
        if (fieldNodes.length) {
            inlineFragmentSelections.push(this._createInlineFragmentForFieldNodes(this._parentSchemaType, fieldNodes));
        }
        const selectionNodesByTypeName = new Map();
        this._collectInlineFragments(this._parentSchemaType, inlineFragmentSelections, selectionNodesByTypeName);
        const possibleTypes = this._getPossibleTypes(this._parentSchemaType);
        if (possibleTypes.length > 0) {
            const sharedFieldNodes = fieldNodes.filter(node => node.name.value === '__typename');
            if (sharedFieldNodes.length) {
                selectionNodesByTypeName.forEach(nodes => {
                    nodes.push(...sharedFieldNodes);
                });
            }
        }
        const fieldSelections = possibleTypes.map(type => {
            const typeName = type.name;
            const schemaType = this._schema.getType(typeName);
            if (!isObjectType(schemaType)) {
                throw new TypeError('Invalid state.');
            }
            const selectionNodes = selectionNodesByTypeName.get(typeName) || [];
            return this.buildSelectionSetString(schemaType, selectionNodes);
        });
        let fieldSelectionString = fieldSelections.join(' | ');
        // wrap in case we have some fragment spreads
        if (fieldSelections.length > 1 && fragmentSpreadNodes.length) {
            fieldSelectionString = `(${fieldSelectionString})`;
        }
        const fragmentSelectionString = this.buildFragmentSpreadString(fragmentSpreadNodes);
        if (!fieldSelectionString && !fragmentSelectionString) {
            throw new TypeError('Invalid State.');
        }
        if (fieldSelectionString && !fragmentSelectionString) {
            return fieldSelectionString;
        }
        else if (!fieldSelectionString && fragmentSelectionString) {
            return fragmentSelectionString;
        }
        return fieldSelectionString + `\n  & ` + fragmentSelectionString + '\n';
    }
    buildFragmentSpreadString(fragmentSpreadNodes) {
        if (!fragmentSpreadNodes.length) {
            return null;
        }
        return fragmentSpreadNodes
            .map(node => {
            const fragmentSuffix = this._dedupeOperationSuffix && node.name.value.toLowerCase().endsWith('fragment') ? '' : 'Fragment';
            return this._convertName(node.name.value, { useTypesPrefix: true, suffix: fragmentSuffix });
        })
            .join(`\n  & `);
    }
    buildSelectionSetString(parentSchemaType, selectionNodes) {
        const primitiveFields = new Map();
        const primitiveAliasFields = new Map();
        const linkFieldSelectionSets = new Map();
        const fragmentSpreadSelectionSets = new Map();
        let requireTypename = false;
        for (const selectionNode of selectionNodes) {
            if (selectionNode.kind === 'Field') {
                if (!selectionNode.selectionSet) {
                    if (selectionNode.alias) {
                        primitiveAliasFields.set(selectionNode.alias.value, selectionNode);
                    }
                    else if (selectionNode.name.value === '__typename') {
                        requireTypename = true;
                    }
                    else {
                        primitiveFields.set(selectionNode.name.value, selectionNode);
                    }
                }
                else {
                    let selectedField = null;
                    const fields = parentSchemaType.getFields();
                    selectedField = fields[selectionNode.name.value];
                    if (isMetadataFieldName(selectionNode.name.value)) {
                        selectedField = metadataFieldMap[selectionNode.name.value];
                    }
                    if (!selectedField) {
                        throw new TypeError(`Could not find field type. ${parentSchemaType}.${selectionNode.name.value}`);
                    }
                    const fieldName = getFieldNodeNameValue(selectionNode);
                    let linkFieldNode = linkFieldSelectionSets.get(fieldName);
                    if (!linkFieldNode) {
                        linkFieldNode = {
                            selectedFieldType: selectedField.type,
                            field: selectionNode,
                        };
                        linkFieldSelectionSets.set(fieldName, linkFieldNode);
                    }
                    else {
                        mergeSelectionSets(linkFieldNode.field.selectionSet, selectionNode.selectionSet);
                    }
                }
            }
            else if (selectionNode.kind === 'FragmentSpread') {
                fragmentSpreadSelectionSets.set(selectionNode.name.value, selectionNode);
            }
        }
        const linkFields = [];
        for (const { field, selectedFieldType } of linkFieldSelectionSets.values()) {
            const realSelectedFieldType = getBaseType(selectedFieldType);
            const selectionSet = this.createNext(realSelectedFieldType, field.selectionSet);
            linkFields.push({
                alias: field.alias ? field.alias.value : undefined,
                name: field.name.value,
                type: realSelectedFieldType.name,
                selectionSet: this.wrapTypeWithModifiers(selectionSet.string.split(`\n`).join(`\n  `), selectedFieldType),
            });
        }
        const parentName = (this._namespacedImportName ? `${this._namespacedImportName}.` : '') +
            this._convertName(parentSchemaType.name, {
                useTypesPrefix: true,
            });
        const typeInfoField = this.buildTypeNameField(parentSchemaType, this._nonOptionalTypename, this._addTypename, requireTypename);
        if (this._preResolveTypes) {
            const primitiveFieldsTypes = this.buildPrimitiveFieldsWithoutPick(parentSchemaType, Array.from(primitiveFields.values()).map(field => field.name.value));
            const primitiveAliasTypes = this.buildAliasedPrimitiveFieldsWithoutPick(parentSchemaType, Array.from(primitiveAliasFields.values()).map(field => ({ alias: field.alias.value, fieldName: field.name.value })));
            const linkFieldsTypes = this.buildLinkFieldsWithoutPick(linkFields);
            return `{ ${[typeInfoField, ...primitiveFieldsTypes, ...primitiveAliasTypes, ...linkFieldsTypes]
                .filter(a => a)
                .map(b => `${b.name}: ${b.type}`)
                .join(', ')} }`;
        }
        let typeInfoString = null;
        if (typeInfoField) {
            typeInfoString = `{ ${typeInfoField.name}: ${typeInfoField.type} }`;
        }
        const primitiveFieldsString = this.buildPrimitiveFields(parentName, Array.from(primitiveFields.values()).map(field => field.name.value));
        const primitiveAliasFieldsString = this.buildAliasedPrimitiveFields(parentName, Array.from(primitiveAliasFields.values()).map(field => ({ alias: field.alias.value, fieldName: field.name.value })));
        const linkFieldsString = this.buildLinkFields(linkFields);
        const fragmentSpreadString = this.buildFragmentSpreadString([...fragmentSpreadSelectionSets.values()]);
        const result = [typeInfoString, primitiveFieldsString, primitiveAliasFieldsString, linkFieldsString, fragmentSpreadString].filter(Boolean);
        if (result.length === 0) {
            return null;
        }
        else if (result.length === 1) {
            return result[0];
        }
        else {
            return `(\n  ` + result.join(`\n  & `) + `\n)`;
        }
    }
    buildFieldsWithoutPick(parentType) {
        const typeName = this.buildTypeNameField(parentType);
        const baseFields = this.buildPrimitiveFieldsWithoutPick(this._parentSchemaType, this._primitiveFields);
        const linksFields = this.buildLinkFieldsWithoutPick(this._linksFields);
        const aliasBaseFields = this.buildAliasedPrimitiveFieldsWithoutPick(this._parentSchemaType, this._primitiveAliasedFields);
        let mergedFields = `{ ${[typeName, ...baseFields, ...aliasBaseFields, ...linksFields]
            .filter(a => a)
            .map(b => `${b.name}: ${b.type}`)
            .join(', ')} }`;
        return mergedFields;
    }
    buildAliasedPrimitiveFieldsWithoutPick(schemaType, fields) {
        if (fields.length === 0) {
            return [];
        }
        return fields.map(aliasedField => {
            const fieldObj = schemaType.getFields()[aliasedField.fieldName];
            const baseType = getBaseType(fieldObj.type);
            const typeToUse = this._scalars[baseType.name] || baseType.name;
            const wrappedType = this.wrapTypeWithModifiers(typeToUse, fieldObj.type);
            return {
                name: this.formatNamedField(aliasedField.alias),
                type: wrappedType,
            };
        });
    }
    buildLinkFieldsWithoutPick(fields) {
        if (fields.length === 0) {
            return [];
        }
        return fields.map(field => ({ name: this.formatNamedField(field.alias || field.name), type: field.selectionSet }));
    }
    buildPrimitiveFieldsWithoutPick(schemaType, fields) {
        if (fields.length === 0) {
            return [];
        }
        return fields.map(field => {
            const fieldObj = schemaType.getFields()[field];
            const baseType = getBaseType(fieldObj.type);
            let typeToUse = baseType.name;
            if (isEnumType(baseType)) {
                typeToUse = (this._namespacedImportName ? `${this._namespacedImportName}.` : '') + this._convertName(baseType.name, { useTypesPrefix: this._enumPrefix });
            }
            else if (this._scalars[baseType.name]) {
                typeToUse = this._scalars[baseType.name];
            }
            const wrappedType = this.wrapTypeWithModifiers(typeToUse, fieldObj.type);
            return {
                name: this.formatNamedField(field),
                type: wrappedType,
            };
        });
    }
    buildTypeNameField(type, nonOptionalTypename = this._nonOptionalTypename, addTypename = this._addTypename, queriedForTypename = this._queriedForTypename) {
        if (nonOptionalTypename || addTypename || queriedForTypename) {
            const optionalTypename = !queriedForTypename && !nonOptionalTypename;
            return {
                name: `${this.formatNamedField('__typename')}${optionalTypename ? '?' : ''}`,
                type: `'${type.name}'`,
            };
        }
        return null;
    }
    buildPrimitiveFields(parentName, fields) {
        if (fields.length === 0) {
            return null;
        }
        return `Pick<${parentName}, ${fields.map(field => `'${field}'`).join(' | ')}>`;
    }
    buildAliasedPrimitiveFields(parentName, fields) {
        if (fields.length === 0) {
            return null;
        }
        return `{ ${fields.map(aliasedField => `${this.formatNamedField(aliasedField.alias)}: ${parentName}['${aliasedField.fieldName}']`).join(', ')} }`;
    }
    formatNamedField(name) {
        return name;
    }
    buildLinkFields(fields) {
        if (fields.length === 0) {
            return null;
        }
        return `{ ${fields.map(field => `${this.formatNamedField(field.alias || field.name)}: ${field.selectionSet}`).join(', ')} }`;
    }
}
//# sourceMappingURL=selection-set-to-object.js.map