import { BaseVisitor } from './base-visitor';
import * as autoBind from 'auto-bind';
import { DEFAULT_SCALARS } from './scalars';
import { DeclarationBlock, indent, getBaseTypeNode, buildScalars, getConfigValue, getBaseType, getRootTypeNames, stripMapperTypeInterpolation, OMIT_TYPE, REQUIRE_FIELDS_TYPE } from './utils';
import { isObjectType, isInterfaceType, isNonNullType, isListType, isUnionType, isEnumType, } from 'graphql';
import { GraphQLObjectType } from 'graphql';
import { OperationVariablesToObject } from './variables-to-object';
import { parseMapper, transformMappers } from './mappers';
import { parseEnumValues } from './enum-values';
import { ApolloFederation } from './federation';
export class BaseResolversVisitor extends BaseVisitor {
    constructor(rawConfig, additionalConfig, _schema, defaultScalars = DEFAULT_SCALARS) {
        super(rawConfig, {
            federation: getConfigValue(rawConfig.federation, false),
            resolverTypeWrapperSignature: getConfigValue(rawConfig.resolverTypeWrapperSignature, 'Promise<T> | T'),
            enumValues: parseEnumValues(_schema, rawConfig.enumValues),
            addUnderscoreToArgsType: getConfigValue(rawConfig.addUnderscoreToArgsType, false),
            contextType: parseMapper(rawConfig.contextType || 'any', 'ContextType'),
            rootValueType: parseMapper(rawConfig.rootValueType || '{}', 'RootValueType'),
            avoidOptionals: getConfigValue(rawConfig.avoidOptionals, false),
            defaultMapper: rawConfig.defaultMapper ? parseMapper(rawConfig.defaultMapper || 'any', 'DefaultMapperType') : null,
            mappers: transformMappers(rawConfig.mappers || {}),
            scalars: buildScalars(_schema, rawConfig.scalars, defaultScalars),
            ...(additionalConfig || {}),
        });
        this._schema = _schema;
        this._declarationBlockConfig = {};
        this._collectedResolvers = {};
        this._collectedDirectiveResolvers = {};
        this._usedMappers = {};
        this._resolversTypes = {};
        this._resolversParentTypes = {};
        this._rootTypeNames = [];
        this._globalDeclarations = new Set();
        autoBind(this);
        this._federation = new ApolloFederation({ enabled: this.config.federation, schema: this.schema });
        this._rootTypeNames = getRootTypeNames(_schema);
        this._variablesTransfomer = new OperationVariablesToObject(this.scalars, this.convertName);
        this._resolversTypes = this.createResolversFields(type => this.applyResolverTypeWrapper(type), type => this.clearResolverTypeWrapper(type));
        this._resolversParentTypes = this.createResolversFields(type => type, type => type);
    }
    getResolverTypeWrapperSignature() {
        return `export type ResolverTypeWrapper<T> = ${this.config.resolverTypeWrapperSignature};`;
    }
    shouldMapType(type, checkedBefore = {}, duringCheck = []) {
        if (checkedBefore[type.name] !== undefined) {
            return checkedBefore[type.name];
        }
        if (type.name.startsWith('__') || this.config.scalars[type.name]) {
            return false;
        }
        if (this.config.mappers[type.name]) {
            return true;
        }
        if (isObjectType(type) || isInterfaceType(type)) {
            const fields = type.getFields();
            return Object.keys(fields)
                .filter(fieldName => {
                const field = fields[fieldName];
                const fieldType = getBaseType(field.type);
                return !duringCheck.includes(fieldType.name);
            })
                .some(fieldName => {
                const field = fields[fieldName];
                const fieldType = getBaseType(field.type);
                if (checkedBefore[fieldType.name] !== undefined) {
                    return checkedBefore[fieldType.name];
                }
                if (this.config.mappers[type.name]) {
                    return true;
                }
                duringCheck.push(type.name);
                const innerResult = this.shouldMapType(fieldType, checkedBefore, duringCheck);
                return innerResult;
            });
        }
        return false;
    }
    // Kamil: this one is heeeeavvyyyy
    createResolversFields(applyWrapper, clearWrapper) {
        const allSchemaTypes = this._schema.getTypeMap();
        const nestedMapping = {};
        const typeNames = this._federation.filterTypeNames(Object.keys(allSchemaTypes));
        typeNames.forEach(typeName => {
            const schemaType = allSchemaTypes[typeName];
            nestedMapping[typeName] = this.shouldMapType(schemaType, nestedMapping);
        });
        return typeNames.reduce((prev, typeName) => {
            if (typeName.startsWith('__')) {
                return prev;
            }
            let shouldApplyOmit = false;
            const isRootType = this._rootTypeNames.includes(typeName);
            const isMapped = this.config.mappers[typeName];
            const isScalar = this.config.scalars[typeName];
            const hasDefaultMapper = !!(this.config.defaultMapper && this.config.defaultMapper.type);
            const schemaType = allSchemaTypes[typeName];
            if (isRootType) {
                prev[typeName] = applyWrapper(this.config.rootValueType.type);
                return prev;
            }
            else if (isEnumType(schemaType) && this.config.enumValues[typeName]) {
                prev[typeName] = this.config.enumValues[typeName].typeIdentifier;
            }
            else if (isMapped && this.config.mappers[typeName].type) {
                this.markMapperAsUsed(typeName);
                prev[typeName] = applyWrapper(this.config.mappers[typeName].type);
            }
            else if (hasDefaultMapper && !hasPlaceholder(this.config.defaultMapper.type)) {
                prev[typeName] = applyWrapper(this.config.defaultMapper.type);
            }
            else if (isScalar) {
                prev[typeName] = applyWrapper(this._getScalar(typeName));
            }
            else if (isUnionType(schemaType)) {
                prev[typeName] = schemaType
                    .getTypes()
                    .map(type => this.getTypeToUse(type.name))
                    .join(' | ');
            }
            else {
                shouldApplyOmit = true;
                prev[typeName] = this.convertName(typeName);
            }
            if ((shouldApplyOmit && prev[typeName] !== 'any' && isObjectType(schemaType)) || (isInterfaceType(schemaType) && !isMapped)) {
                const fields = schemaType.getFields();
                const relevantFields = this._federation
                    .filterFieldNames(Object.keys(fields))
                    .map(fieldName => {
                    const field = fields[fieldName];
                    const baseType = getBaseType(field.type);
                    const isUnion = isUnionType(baseType);
                    if (!this.config.mappers[baseType.name] && !isUnion && !nestedMapping[baseType.name]) {
                        return null;
                    }
                    const addOptionalSign = !this.config.avoidOptionals && !isNonNullType(field.type);
                    return {
                        addOptionalSign,
                        fieldName,
                        replaceWithType: this.wrapTypeWithModifiers(this.getTypeToUse(baseType.name), field.type),
                    };
                })
                    .filter(a => a);
                if (relevantFields.length > 0) {
                    // Puts ResolverTypeWrapper on top of an entire type
                    prev[typeName] = applyWrapper(this.replaceFieldsInType(prev[typeName], relevantFields));
                }
                else {
                    // We still want to use ResolverTypeWrapper, even if we don't touch any fields
                    prev[typeName] = applyWrapper(prev[typeName]);
                }
            }
            if (isMapped && hasPlaceholder(prev[typeName])) {
                prev[typeName] = replacePlaceholder(prev[typeName], typeName);
            }
            if (!isMapped && hasDefaultMapper && hasPlaceholder(this.config.defaultMapper.type)) {
                // Make sure the inner type has no ResolverTypeWrapper
                const name = clearWrapper(isScalar ? this._getScalar(typeName) : prev[typeName]);
                const replaced = replacePlaceholder(this.config.defaultMapper.type, name);
                // Don't wrap Union with ResolverTypeWrapper, each inner type already has it
                if (isUnionType(schemaType)) {
                    prev[typeName] = replaced;
                }
                else {
                    prev[typeName] = applyWrapper(replacePlaceholder(this.config.defaultMapper.type, name));
                }
            }
            return prev;
        }, {});
    }
    replaceFieldsInType(typeName, relevantFields) {
        this._globalDeclarations.add(OMIT_TYPE);
        return `Omit<${typeName}, ${relevantFields.map(f => `'${f.fieldName}'`).join(' | ')}> & { ${relevantFields.map(f => `${f.fieldName}${f.addOptionalSign ? '?' : ''}: ${f.replaceWithType}`).join(', ')} }`;
    }
    applyMaybe(str) {
        return `Maybe<${str}>`;
    }
    applyResolverTypeWrapper(str) {
        return `ResolverTypeWrapper<${this.clearResolverTypeWrapper(str)}>`;
    }
    clearMaybe(str) {
        if (str.startsWith('Maybe<')) {
            return str.replace(/Maybe<(.*?)>$/, '$1');
        }
        return str;
    }
    clearResolverTypeWrapper(str) {
        if (str.startsWith('ResolverTypeWrapper<')) {
            return str.replace(/ResolverTypeWrapper<(.*?)>$/, '$1');
        }
        return str;
    }
    wrapTypeWithModifiers(baseType, type) {
        if (isNonNullType(type)) {
            return this.clearMaybe(this.wrapTypeWithModifiers(baseType, type.ofType));
        }
        else if (isListType(type)) {
            const innerType = this.wrapTypeWithModifiers(baseType, type.ofType);
            return this.applyMaybe(`Array<${innerType}>`);
        }
        else {
            // ResolverTypeWrapper here?
            return this.applyMaybe(baseType);
        }
    }
    buildResolversTypes() {
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName('ResolversTypes'))
            .withComment('Mapping between all available schema types and the resolvers types')
            .withBlock(Object.keys(this._resolversTypes)
            .map(typeName => indent(`${typeName}: ${this._resolversTypes[typeName]},`))
            .join('\n')).string;
    }
    buildResolversParentTypes() {
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName('ResolversParentTypes'))
            .withComment('Mapping between all available schema types and the resolvers parents')
            .withBlock(Object.keys(this._resolversParentTypes)
            .map(typeName => indent(`${typeName}: ${this._resolversParentTypes[typeName]},`))
            .join('\n')).string;
    }
    get schema() {
        return this._schema;
    }
    get defaultMapperType() {
        return this.config.defaultMapper.type;
    }
    get unusedMappers() {
        return Object.keys(this.config.mappers).filter(name => !this._usedMappers[name]);
    }
    get globalDeclarations() {
        return Array.from(this._globalDeclarations);
    }
    get mappersImports() {
        const groupedMappers = {};
        const addMapper = (source, identifier, asDefault) => {
            if (!groupedMappers[source]) {
                groupedMappers[source] = [];
            }
            if (!groupedMappers[source].find(m => m.identifier === identifier)) {
                groupedMappers[source].push({ identifier, asDefault });
            }
        };
        Object.keys(this.config.mappers)
            .map(gqlTypeName => this.config.mappers[gqlTypeName])
            .filter((gqlType) => gqlType.isExternal)
            .forEach(mapper => {
            const identifier = stripMapperTypeInterpolation(mapper.type);
            addMapper(mapper.source, identifier, mapper.default);
        });
        if (this.config.contextType.isExternal) {
            addMapper(this.config.contextType.source, this.config.contextType.import, this.config.contextType.default);
        }
        if (this.config.rootValueType.isExternal) {
            addMapper(this.config.rootValueType.source, this.config.rootValueType.import, this.config.rootValueType.default);
        }
        if (this.config.defaultMapper && this.config.defaultMapper.isExternal) {
            const identifier = stripMapperTypeInterpolation(this.config.defaultMapper.import);
            addMapper(this.config.defaultMapper.source, identifier, this.config.defaultMapper.default);
        }
        return Object.keys(groupedMappers).map(source => this.buildMapperImport(source, groupedMappers[source]));
    }
    buildMapperImport(source, types) {
        if (types[0] && types[0].asDefault) {
            return `import ${types[0].identifier} from '${source}';`;
        }
        return `import { ${types.map(t => t.identifier).join(', ')} } from '${source}';`;
    }
    setDeclarationBlockConfig(config) {
        this._declarationBlockConfig = config;
    }
    setVariablesTransformer(variablesTransfomer) {
        this._variablesTransfomer = variablesTransfomer;
    }
    getRootResolver() {
        const name = this.convertName('Resolvers');
        const contextType = `<ContextType = ${this.config.contextType.type}>`;
        // This is here because we don't want to break IResolvers, so there is a mapping by default,
        // and if the developer is overriding typesPrefix, it won't get generated at all.
        const deprecatedIResolvers = !this.config.typesPrefix
            ? `
/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
*/
export type IResolvers${contextType} = ${name}<ContextType>;`
            : '';
        return [
            new DeclarationBlock(this._declarationBlockConfig)
                .export()
                .asKind('type')
                .withName(name, contextType)
                .withBlock(Object.keys(this._collectedResolvers)
                .map(schemaTypeName => {
                const resolverType = this._collectedResolvers[schemaTypeName];
                return indent(this.formatRootResolver(schemaTypeName, resolverType));
            })
                .join('\n')).string,
            deprecatedIResolvers,
        ].join('\n');
    }
    formatRootResolver(schemaTypeName, resolverType) {
        return `${schemaTypeName}${this.config.avoidOptionals ? '' : '?'}: ${resolverType},`;
    }
    getAllDirectiveResolvers() {
        if (Object.keys(this._collectedDirectiveResolvers).length) {
            const name = this.convertName('DirectiveResolvers');
            const contextType = `<ContextType = ${this.config.contextType.type}>`;
            // This is here because we don't want to break IResolvers, so there is a mapping by default,
            // and if the developer is overriding typesPrefix, it won't get generated at all.
            const deprecatedIResolvers = !this.config.typesPrefix
                ? `
/**
* @deprecated
* Use "DirectiveResolvers" root object instead. If you wish to get "IDirectiveResolvers", add "typesPrefix: I" to your config.
*/
export type IDirectiveResolvers${contextType} = ${name}<ContextType>;`
                : '';
            return [
                new DeclarationBlock(this._declarationBlockConfig)
                    .export()
                    .asKind('type')
                    .withName(name, contextType)
                    .withBlock(Object.keys(this._collectedDirectiveResolvers)
                    .map(schemaTypeName => {
                    const resolverType = this._collectedDirectiveResolvers[schemaTypeName];
                    return indent(this.formatRootResolver(schemaTypeName, resolverType));
                })
                    .join('\n')).string,
                deprecatedIResolvers,
            ].join('\n');
        }
        return '';
    }
    Name(node) {
        return node.value;
    }
    ListType(node) {
        const asString = node.type;
        return `Array<${asString}>`;
    }
    _getScalar(name) {
        return `Scalars['${name}']`;
    }
    NamedType(node) {
        const nameStr = node.name;
        if (this.config.scalars[nameStr]) {
            return this._getScalar(nameStr);
        }
        return this.convertName(node);
    }
    NonNullType(node) {
        const asString = node.type;
        return asString;
    }
    markMapperAsUsed(name) {
        this._usedMappers[name] = true;
    }
    getTypeToUse(name) {
        const resolversType = this.convertName('ResolversTypes');
        return `${resolversType}['${name}']`;
    }
    getParentTypeToUse(name) {
        const resolversType = this.convertName('ResolversParentTypes');
        return `${resolversType}['${name}']`;
    }
    transformParentGenericType(parentType) {
        return `ParentType extends ${parentType} = ${parentType}`;
    }
    FieldDefinition(node, key, parent) {
        const hasArguments = node.arguments && node.arguments.length > 0;
        return (parentName) => {
            const original = parent[key];
            const baseType = getBaseTypeNode(original.type);
            const realType = baseType.name.value;
            const parentType = this.schema.getType(parentName);
            if (this._federation.skipField({ fieldNode: original, parentType: parentType })) {
                return null;
            }
            const typeToUse = this.getTypeToUse(realType);
            const mappedType = this._variablesTransfomer.wrapAstTypeWithModifiers(typeToUse, original.type);
            const subscriptionType = this._schema.getSubscriptionType();
            const isSubscriptionType = subscriptionType && subscriptionType.name === parentName;
            let argsType = hasArguments
                ? `${this.convertName(parentName, {
                    useTypesPrefix: true,
                }) +
                    (this.config.addUnderscoreToArgsType ? '_' : '') +
                    this.convertName(node.name, {
                        useTypesPrefix: false,
                    }) +
                    'Args'}`
                : null;
            if (argsType !== null) {
                const argsToForceRequire = original.arguments.filter(arg => !!arg.defaultValue || arg.type.kind === 'NonNullType');
                if (argsToForceRequire.length > 0) {
                    argsType = this.applyRequireFields(argsType, argsToForceRequire);
                }
            }
            const parentTypeSignature = this._federation.translateParentType({ fieldNode: original, parentType, parentTypeSignature: 'ParentType' });
            const mappedTypeKey = isSubscriptionType ? `${mappedType}, "${node.name}"` : mappedType;
            return indent(`${node.name}${this.config.avoidOptionals ? '' : '?'}: ${isSubscriptionType ? 'SubscriptionResolver' : 'Resolver'}<${mappedTypeKey}, ${parentTypeSignature}, ContextType${argsType ? `, ${argsType}` : ''}>,`);
        };
    }
    applyRequireFields(argsType, fields) {
        this._globalDeclarations.add(REQUIRE_FIELDS_TYPE);
        return `RequireFields<${argsType}, ${fields.map(f => `'${f.name.value}'`).join(' | ')}>`;
    }
    ObjectTypeDefinition(node) {
        const name = this.convertName(node, {
            suffix: 'Resolvers',
        });
        const parentType = this.getParentTypeToUse(node.name);
        const block = new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(name, `<ContextType = ${this.config.contextType.type}, ${this.transformParentGenericType(parentType)}>`)
            .withBlock(node.fields.map((f) => f(node.name)).join('\n'));
        this._collectedResolvers[node.name] = name + '<ContextType>';
        return block.string;
    }
    UnionTypeDefinition(node, key, parent) {
        const name = this.convertName(node, {
            suffix: 'Resolvers',
        });
        const originalNode = parent[key];
        const possibleTypes = originalNode.types
            .map(node => node.name.value)
            .map(f => `'${f}'`)
            .join(' | ');
        this._collectedResolvers[node.name] = name;
        const parentType = this.getParentTypeToUse(node.name);
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(name, `<ContextType = ${this.config.contextType.type}, ${this.transformParentGenericType(parentType)}>`)
            .withBlock(indent(`__resolveType: TypeResolveFn<${possibleTypes}, ParentType, ContextType>`)).string;
    }
    ScalarTypeDefinition(node) {
        const nameAsString = node.name;
        const baseName = this.getTypeToUse(nameAsString);
        if (this._federation.skipScalar(nameAsString)) {
            return null;
        }
        this._collectedResolvers[node.name] = 'GraphQLScalarType';
        return new DeclarationBlock({
            ...this._declarationBlockConfig,
            blockTransformer(block) {
                return block;
            },
        })
            .export()
            .asKind('interface')
            .withName(this.convertName(node, {
            suffix: 'ScalarConfig',
        }), ` extends GraphQLScalarTypeConfig<${baseName}, any>`)
            .withBlock(indent(`name: '${node.name}'`)).string;
    }
    DirectiveDefinition(node) {
        if (this._federation.skipDirective(node.name)) {
            return null;
        }
        const directiveName = this.convertName(node, {
            suffix: 'DirectiveResolver',
        });
        const hasArguments = node.arguments && node.arguments.length > 0;
        const directiveArgs = hasArguments ? this._variablesTransfomer.transform(node.arguments) : '';
        this._collectedDirectiveResolvers[node.name] = directiveName + '<any, any, ContextType>';
        return new DeclarationBlock({
            ...this._declarationBlockConfig,
            blockTransformer(block) {
                return block;
            },
        })
            .export()
            .asKind('type')
            .withName(directiveName, `<Result, Parent, ContextType = ${this.config.contextType.type}, Args = { ${directiveArgs} }>`)
            .withContent(`DirectiveResolverFn<Result, Parent, ContextType, Args>`).string;
    }
    InterfaceTypeDefinition(node) {
        const name = this.convertName(node, {
            suffix: 'Resolvers',
        });
        const allTypesMap = this._schema.getTypeMap();
        const implementingTypes = [];
        this._collectedResolvers[node.name] = name;
        for (const graphqlType of Object.values(allTypesMap)) {
            if (graphqlType instanceof GraphQLObjectType) {
                const allInterfaces = graphqlType.getInterfaces();
                if (allInterfaces.find(int => int.name === node.name)) {
                    implementingTypes.push(graphqlType.name);
                }
            }
        }
        const parentType = this.getParentTypeToUse(node.name);
        const possibleTypes = implementingTypes.map(name => `'${name}'`).join(' | ') || 'null';
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(name, `<ContextType = ${this.config.contextType.type}, ${this.transformParentGenericType(parentType)}>`)
            .withBlock([indent(`__resolveType: TypeResolveFn<${possibleTypes}, ParentType, ContextType>,`), ...(node.fields || []).map((f) => f(node.name))].join('\n')).string;
    }
    SchemaDefinition() {
        return null;
    }
}
function replacePlaceholder(pattern, typename) {
    return pattern.replace('{T}', typename);
}
function hasPlaceholder(pattern) {
    return pattern.includes('{T}');
}
//# sourceMappingURL=base-resolvers-visitor.js.map