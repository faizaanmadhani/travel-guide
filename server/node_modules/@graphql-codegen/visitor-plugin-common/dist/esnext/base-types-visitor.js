import { isEnumType, } from 'graphql';
import { BaseVisitor } from './base-visitor';
import { DEFAULT_SCALARS } from './scalars';
import { normalizeDeclarationKind } from './declaration-kinds';
import { transformComment, buildScalars, DeclarationBlock, indent, wrapWithSingleQuotes, getConfigValue } from './utils';
import { OperationVariablesToObject } from './variables-to-object';
import { parseEnumValues } from './enum-values';
export class BaseTypesVisitor extends BaseVisitor {
    constructor(_schema, rawConfig, additionalConfig, defaultScalars = DEFAULT_SCALARS) {
        super(rawConfig, {
            enumPrefix: getConfigValue(rawConfig.enumPrefix, true),
            addUnderscoreToArgsType: getConfigValue(rawConfig.addUnderscoreToArgsType, false),
            enumValues: parseEnumValues(_schema, rawConfig.enumValues),
            declarationKind: normalizeDeclarationKind(rawConfig.declarationKind),
            scalars: buildScalars(_schema, rawConfig.scalars, defaultScalars),
            ...additionalConfig,
        });
        this._schema = _schema;
        this._argumentsTransformer = new OperationVariablesToObject(this.scalars, this.convertName);
    }
    getScalarsImports() {
        return Object.keys(this.config.scalars)
            .map(enumName => {
            const mappedValue = this.config.scalars[enumName];
            if (mappedValue.isExternal) {
                return this._buildTypeImport(mappedValue.import, mappedValue.source, mappedValue.default);
            }
            return null;
        })
            .filter(a => a);
    }
    get scalarsDefinition() {
        const allScalars = Object.keys(this.config.scalars).map(scalarName => {
            const scalarValue = this.config.scalars[scalarName].type;
            const scalarType = this._schema.getType(scalarName);
            const comment = scalarType && scalarType.astNode && scalarType.description ? transformComment(scalarType.description, 1) : '';
            return comment + indent(`${scalarName}: ${scalarValue},`);
        });
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind(this._parsedConfig.declarationKind.scalar)
            .withName('Scalars')
            .withComment('All built-in and custom scalars, mapped to their actual values')
            .withBlock(allScalars.join('\n')).string;
    }
    setDeclarationBlockConfig(config) {
        this._declarationBlockConfig = config;
    }
    setArgumentsTransformer(argumentsTransfomer) {
        this._argumentsTransformer = argumentsTransfomer;
    }
    NonNullType(node) {
        const asString = node.type;
        return asString;
    }
    getInputObjectDeclarationBlock(node) {
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind(this._parsedConfig.declarationKind.input)
            .withName(this.convertName(node))
            .withComment(node.description)
            .withBlock(node.fields.join('\n'));
    }
    InputObjectTypeDefinition(node) {
        return this.getInputObjectDeclarationBlock(node).string;
    }
    InputValueDefinition(node) {
        const comment = transformComment(node.description, 1);
        return comment + indent(`${node.name}: ${node.type},`);
    }
    Name(node) {
        return node.value;
    }
    FieldDefinition(node) {
        const typeString = node.type;
        const comment = transformComment(node.description, 1);
        return comment + indent(`${node.name}: ${typeString},`);
    }
    UnionTypeDefinition(node, key, parent) {
        const originalNode = parent[key];
        const possibleTypes = originalNode.types.map(t => (this.scalars[t.name.value] ? this._getScalar(t.name.value) : this.convertName(t))).join(' | ');
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName(node))
            .withComment(node.description)
            .withContent(possibleTypes).string;
    }
    getObjectTypeDeclarationBlock(node, originalNode) {
        const optionalTypename = this.config.nonOptionalTypename ? '__typename' : '__typename?';
        const { type } = this._parsedConfig.declarationKind;
        const allFields = [...(this.config.addTypename ? [indent(`${this.config['immutableTypes'] ? 'readonly' : ''} ${optionalTypename}: '${node.name}'${type === 'class' ? ';' : ','}`)] : []), ...node.fields];
        const buildInterfaces = () => {
            if (!originalNode.interfaces || !node.interfaces.length) {
                return '';
            }
            const interfaces = originalNode.interfaces.map(i => this.convertName(i));
            if (type === 'interface' || type === 'class') {
                return ' extends ' + interfaces.join(', ') + (allFields.length ? ' ' : ' {}');
            }
            return interfaces.join(' & ') + (allFields.length ? ' & ' : '');
        };
        const interfaces = buildInterfaces();
        let declarationBlock = new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind(type)
            .withName(this.convertName(node))
            .withContent(interfaces)
            .withComment(node.description);
        return declarationBlock.withBlock(allFields.join('\n'));
    }
    ObjectTypeDefinition(node, key, parent) {
        const originalNode = parent[key];
        return [this.getObjectTypeDeclarationBlock(node, originalNode).string, this.buildArgumentsBlock(originalNode)].filter(f => f).join('\n\n');
    }
    getInterfaceTypeDeclarationBlock(node, originalNode) {
        const argumentsBlock = this.buildArgumentsBlock(originalNode);
        let declarationBlock = new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind(this._parsedConfig.declarationKind.interface)
            .withName(this.convertName(node))
            .withComment(node.description);
        return declarationBlock.withBlock(node.fields.join('\n'));
    }
    InterfaceTypeDefinition(node, key, parent) {
        const originalNode = parent[key];
        return [this.getInterfaceTypeDeclarationBlock(node, originalNode).string, this.buildArgumentsBlock(originalNode)].filter(f => f).join('\n\n');
    }
    ScalarTypeDefinition(node) {
        // We empty this because we handle scalars in a different way, see constructor.
        return '';
    }
    _buildTypeImport(identifier, source, asDefault = false) {
        if (asDefault) {
            return `import ${identifier} from '${source}';`;
        }
        return `import { ${identifier} } from '${source}';`;
    }
    getEnumsImports() {
        return Object.keys(this.config.enumValues)
            .map(enumName => {
            const mappedValue = this.config.enumValues[enumName];
            if (mappedValue.sourceFile) {
                if (mappedValue.sourceIdentifier === 'default') {
                    return this._buildTypeImport(mappedValue.typeIdentifier, mappedValue.sourceFile, true);
                }
                const identifier = mappedValue.sourceIdentifier !== mappedValue.typeIdentifier ? `${mappedValue.sourceIdentifier} as ${mappedValue.typeIdentifier}` : mappedValue.sourceIdentifier;
                return this._buildTypeImport(identifier, mappedValue.sourceFile);
            }
            return null;
        })
            .filter(a => a);
    }
    EnumTypeDefinition(node) {
        const enumName = node.name;
        // In case of mapped external enum string
        if (this.config.enumValues[enumName] && this.config.enumValues[enumName].sourceFile) {
            return null;
        }
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('enum')
            .withName(this.convertName(node, { useTypesPrefix: this.config.enumPrefix }))
            .withComment(node.description)
            .withBlock(this.buildEnumValuesBlock(enumName, node.values)).string;
    }
    // We are using it in order to transform "description" field
    StringValue(node) {
        return node.value;
    }
    buildEnumValuesBlock(typeName, values) {
        return values
            .map(enumOption => {
            const optionName = this.convertName(enumOption, { useTypesPrefix: false, transformUnderscore: true });
            const comment = transformComment(enumOption.description, 1);
            let enumValue = enumOption.name;
            if (this.config.enumValues[typeName] && this.config.enumValues[typeName].mappedValues && this.config.enumValues[typeName].mappedValues[enumValue]) {
                enumValue = this.config.enumValues[typeName].mappedValues[enumValue];
            }
            return comment + indent(`${optionName}${this._declarationBlockConfig.enumNameValueSeparator} ${wrapWithSingleQuotes(enumValue)}`);
        })
            .join(',\n');
    }
    DirectiveDefinition(node) {
        return '';
    }
    getArgumentsObjectDeclarationBlock(node, name, field) {
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind(this._parsedConfig.declarationKind.arguments)
            .withName(this.convertName(name))
            .withComment(node.description)
            .withBlock(this._argumentsTransformer.transform(field.arguments));
    }
    getArgumentsObjectTypeDefinition(node, name, field) {
        return this.getArgumentsObjectDeclarationBlock(node, name, field).string;
    }
    buildArgumentsBlock(node) {
        const fieldsWithArguments = node.fields.filter(field => field.arguments && field.arguments.length > 0) || [];
        return fieldsWithArguments
            .map(field => {
            const name = node.name.value +
                (this.config.addUnderscoreToArgsType ? '_' : '') +
                this.convertName(field, {
                    useTypesPrefix: false,
                }) +
                'Args';
            return this.getArgumentsObjectTypeDefinition(node, name, field);
        })
            .join('\n\n');
    }
    _getScalar(name) {
        return `Scalars['${name}']`;
    }
    _getTypeForNode(node) {
        const typeAsString = node.name;
        if (this.scalars[typeAsString]) {
            return this._getScalar(typeAsString);
        }
        else if (this.config.enumValues[typeAsString]) {
            return this.config.enumValues[typeAsString].typeIdentifier;
        }
        const schemaType = this._schema.getType(node.name);
        if (schemaType && isEnumType(schemaType)) {
            return this.convertName(node, { useTypesPrefix: this.config.enumPrefix });
        }
        return this.convertName(node);
    }
    NamedType(node) {
        return this._getTypeForNode(node);
    }
    ListType(node) {
        const asString = node.type;
        return this.wrapWithListType(asString);
    }
    SchemaDefinition() {
        return null;
    }
    wrapWithListType(str) {
        return `Array<${str}>`;
    }
}
//# sourceMappingURL=base-types-visitor.js.map