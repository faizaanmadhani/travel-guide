import * as AggregateError from 'aggregate-error';
import { Kind, concatAST, validate, specifiedRules } from 'graphql';
const DEFAULT_IGNORED_RULES = ['NoUnusedFragments', 'NoUnusedVariables', 'KnownDirectives'];
const DEFAULT_EFFECTIVE_RULES = specifiedRules.filter((f) => !DEFAULT_IGNORED_RULES.includes(f.name));
export const validateGraphQlDocuments = (schema, documentFiles, effectiveRules = DEFAULT_EFFECTIVE_RULES) => {
    const allAst = concatAST(documentFiles.map(m => m.content));
    const allFragments = allAst.definitions.filter(d => d.kind === Kind.FRAGMENT_DEFINITION);
    return documentFiles
        .map(file => {
        const documentToValidate = {
            kind: Kind.DOCUMENT,
            definitions: [...allFragments, ...file.content.definitions].filter((d, index, arr) => {
                if (d.kind === Kind.FRAGMENT_DEFINITION) {
                    const foundIndex = arr.findIndex(i => i.kind === Kind.FRAGMENT_DEFINITION && i.name.value === d.name.value);
                    if (foundIndex !== index) {
                        return false;
                    }
                }
                return true;
            }),
        };
        return {
            filePath: file.filePath,
            errors: validate(schema, documentToValidate, effectiveRules),
        };
    })
        .filter(r => r.errors.length > 0);
};
export function checkValidationErrors(loadDocumentErrors) {
    if (loadDocumentErrors.length > 0) {
        const errors = [];
        for (const loadDocumentError of loadDocumentErrors) {
            for (const graphQLError of loadDocumentError.errors) {
                const error = new Error();
                error.name = 'GraphQLDocumentError';
                error.message = `${error.name}: ${graphQLError.message}`;
                error.stack = error.message;
                graphQLError.locations.forEach(location => (error.stack += `\n    at ${loadDocumentError.filePath}:${location.line}:${location.column}`));
                errors.push(error);
            }
        }
        throw new AggregateError(errors);
    }
}
//# sourceMappingURL=validate-documents.js.map