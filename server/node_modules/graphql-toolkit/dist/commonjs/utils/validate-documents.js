"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AggregateError = require("aggregate-error");
const graphql_1 = require("graphql");
const DEFAULT_IGNORED_RULES = ['NoUnusedFragments', 'NoUnusedVariables', 'KnownDirectives'];
const DEFAULT_EFFECTIVE_RULES = graphql_1.specifiedRules.filter((f) => !DEFAULT_IGNORED_RULES.includes(f.name));
exports.validateGraphQlDocuments = (schema, documentFiles, effectiveRules = DEFAULT_EFFECTIVE_RULES) => {
    const allAst = graphql_1.concatAST(documentFiles.map(m => m.content));
    const allFragments = allAst.definitions.filter(d => d.kind === graphql_1.Kind.FRAGMENT_DEFINITION);
    return documentFiles
        .map(file => {
        const documentToValidate = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: [...allFragments, ...file.content.definitions].filter((d, index, arr) => {
                if (d.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
                    const foundIndex = arr.findIndex(i => i.kind === graphql_1.Kind.FRAGMENT_DEFINITION && i.name.value === d.name.value);
                    if (foundIndex !== index) {
                        return false;
                    }
                }
                return true;
            }),
        };
        return {
            filePath: file.filePath,
            errors: graphql_1.validate(schema, documentToValidate, effectiveRules),
        };
    })
        .filter(r => r.errors.length > 0);
};
function checkValidationErrors(loadDocumentErrors) {
    if (loadDocumentErrors.length > 0) {
        const errors = [];
        for (const loadDocumentError of loadDocumentErrors) {
            for (const graphQLError of loadDocumentError.errors) {
                const error = new Error();
                error.name = 'GraphQLDocumentError';
                error.message = `${error.name}: ${graphQLError.message}`;
                error.stack = error.message;
                graphQLError.locations.forEach(location => (error.stack += `\n    at ${loadDocumentError.filePath}:${location.line}:${location.column}`));
                errors.push(error);
            }
        }
        throw new AggregateError(errors);
    }
}
exports.checkValidationErrors = checkValidationErrors;
//# sourceMappingURL=validate-documents.js.map