<?xml version="1.0" encoding="UTF-8"?>
<testsuites name="jest tests" tests="162" failures="0" time="2.735">
  <testsuite name="Merge Resolvers" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:16" time="1.439" tests="7">
    <testcase classname="Merge Resolvers" name="should return the correct value when falsely value provided" time="0.003" file="tests/epoxy/merge-resolvers.spec.ts">
    </testcase>
    <testcase classname="Merge Resolvers" name="should return the correct value when empty array provided" time="0" file="tests/epoxy/merge-resolvers.spec.ts">
    </testcase>
    <testcase classname="Merge Resolvers" name="should return the correct value when one value array provided" time="0" file="tests/epoxy/merge-resolvers.spec.ts">
    </testcase>
    <testcase classname="Merge Resolvers" name="should return the correct when multiple values provided" time="0.001" file="tests/epoxy/merge-resolvers.spec.ts">
    </testcase>
    <testcase classname="Merge Resolvers" name="should merge first level fields" time="0" file="tests/epoxy/merge-resolvers.spec.ts">
    </testcase>
    <testcase classname="Merge Resolvers" name="should exclude types" time="0.001" file="tests/epoxy/merge-resolvers.spec.ts">
    </testcase>
    <testcase classname="Merge Resolvers" name="should exclude fields" time="0" file="tests/epoxy/merge-resolvers.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="Schema From Export" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:16" time="1.318" tests="5">
    <testcase classname="Schema From Export" name="should load the schema correctly from module.exports" time="0.192" file="tests/loaders/schema/schema-from-export.spec.ts">
    </testcase>
    <testcase classname="Schema From Export" name="should load the schema (with extend) correctly from module.exports" time="0.015" file="tests/loaders/schema/schema-from-export.spec.ts">
    </testcase>
    <testcase classname="Schema From Export" name="should load the schema correctly from variable export" time="0.013" file="tests/loaders/schema/schema-from-export.spec.ts">
    </testcase>
    <testcase classname="Schema From Export" name="should load the schema correctly from default export" time="0.006" file="tests/loaders/schema/schema-from-export.spec.ts">
    </testcase>
    <testcase classname="Schema From Export" name="should load the schema correctly from promise export" time="0.004" file="tests/loaders/schema/schema-from-export.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="Schema URL Loader" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:16" time="1.632" tests="5">
    <testcase classname="Schema URL Loader handle" name="Should throw an error when introspection is not valid" time="0.032" file="tests/loaders/schema/url-loader.spec.ts">
    </testcase>
    <testcase classname="Schema URL Loader handle" name="Should return a valid schema when request is valid" time="0.021" file="tests/loaders/schema/url-loader.spec.ts">
    </testcase>
    <testcase classname="Schema URL Loader handle" name="Should pass default headers" time="0.016" file="tests/loaders/schema/url-loader.spec.ts">
    </testcase>
    <testcase classname="Schema URL Loader handle" name="Should pass extra headers when they are specified as object" time="0.011" file="tests/loaders/schema/url-loader.spec.ts">
    </testcase>
    <testcase classname="Schema URL Loader handle" name="Should pass extra headers when they are specified as array" time="0.002" file="tests/loaders/schema/url-loader.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="documentsFromGlob" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:16" time="1.517" tests="8">
    <testcase classname="documentsFromGlob" name="Should load one GraphQL document from glob expression" time="0.021" file="tests/loaders/documents/documents-from-glob.spec.ts">
    </testcase>
    <testcase classname="documentsFromGlob" name="Should load multiple GraphQL document from glob expression" time="0.002" file="tests/loaders/documents/documents-from-glob.spec.ts">
    </testcase>
    <testcase classname="documentsFromGlob" name="Should load two GraphQL documents both for gatsby and graphql-tag by default" time="0.232" file="tests/loaders/documents/documents-from-glob.spec.ts">
    </testcase>
    <testcase classname="documentsFromGlob" name="Should load GraphQL documents that match custom settings" time="0.003" file="tests/loaders/documents/documents-from-glob.spec.ts">
    </testcase>
    <testcase classname="documentsFromGlob" name="Should throw on empty files and empty result" time="0.001" file="tests/loaders/documents/documents-from-glob.spec.ts">
    </testcase>
    <testcase classname="documentsFromGlob" name="Should ignore schema definitions" time="0.001" file="tests/loaders/documents/documents-from-glob.spec.ts">
    </testcase>
    <testcase classname="documentsFromGlob" name="Should ignore files that is added to ignore glob (using options.ignore)" time="0.002" file="tests/loaders/documents/documents-from-glob.spec.ts">
    </testcase>
    <testcase classname="documentsFromGlob" name="Should ignore files that is added to ignore glob (using negative glob)" time="0.001" file="tests/loaders/documents/documents-from-glob.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="file scanner" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:16" time="1.571" tests="16">
    <testcase classname="file scanner schema" name="should return the correct schema results for path: ./tests/sonar/test-assets/1 (one file)" time="0.011" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner schema" name="should return the correct schema results for path: ./tests/sonar/test-assets/2 (multiple files)" time="0.018" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner schema" name="should return the correct schema results for path: ./tests/sonar/test-assets/3 (recursive)" time="0" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner schema" name="should return the correct schema results for path: ./tests/sonar/test-assets/4 (custom extension)" time="0.001" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner schema" name="should return the correct schema results for path: ./tests/sonar/test-assets/5 (custom extensions)" time="0.001" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner schema" name="should return the correct schema results for path: ./tests/sonar/test-assets/10 (code files with gql tag)" time="0.005" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner schema" name="should return the correct schema results for path: ./tests/sonar/test-assets/10 (code files with gql tag)" time="0.031" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner schema" name="should return the correct schema results for path: ./tests/sonar/test-assets/12 (should ignore index on demand)" time="0.001" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner schema" name="should return the correct schema results for path: ./tests/sonar/test-assets/12 (should include index by default)" time="0.001" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner resolvers" name="should return the correct resolvers results for path: ./tests/sonar/test-assets/6 (one file)" time="0.001" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner resolvers" name="should return the correct resolvers results for path: ./tests/sonar/test-assets/7 (multiple files)" time="0.002" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner resolvers" name="should return the correct resolvers results for path: ./tests/sonar/test-assets/8 (default export)" time="0.001" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner resolvers" name="should return the correct resolvers results for path: ./tests/sonar/test-assets/9 (named exports)" time="0.002" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner resolvers" name="should return the correct resolvers results for path: ./tests/sonar/test-assets/11 (ignored extensions)" time="0.015" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner resolvers" name="should return the correct resolvers results for path: ./tests/sonar/test-assets/12 (includes index files but only if it matches extensions)" time="0.002" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
    <testcase classname="file scanner resolvers" name="should return the correct resolvers results for path: ./tests/sonar/test-assets/12 (ingore index files)" time="0.001" file="tests/sonar/file-scanner.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="Resolvers composition" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:17" time="0.305" tests="5">
    <testcase classname="Resolvers composition" name="should compose regular resolvers" time="0.028" file="tests/utils/resolvers-composition.spec.ts">
    </testcase>
    <testcase classname="Resolvers composition" name="should compose resolvers with resolve field" time="0.002" file="tests/utils/resolvers-composition.spec.ts">
    </testcase>
    <testcase classname="Resolvers composition" name="should compose subscription resolvers" time="0.001" file="tests/utils/resolvers-composition.spec.ts">
    </testcase>
    <testcase classname="Resolvers composition" name="should be able to take nested composition objects" time="0.001" file="tests/utils/resolvers-composition.spec.ts">
    </testcase>
    <testcase classname="Resolvers composition" name="should be able to take nested composition objects for subscription resolvers" time="0" file="tests/utils/resolvers-composition.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="Merge Nodes" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:17" time="0.298" tests="22">
    <testcase classname="Merge Nodes type" name="Should merge two GraphQL types correctly when one of them is empty" time="0.029" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes type" name="Should merge two GraphQL Types correctly" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes type" name="Should merge two GraphQL Types correctly when they have shared fields" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes type" name="Should merge GraphQL Types that extends the same interface" time="0" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes type" name="Should merge GraphQL Types that has interface and then override without it" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes type" name="Should merge GraphQL Types and preserve directives and not override" time="0" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes type" name="Should merge GraphQL Types and preserve directives and merge multiple" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes type" name="Should merge GraphQL Types and preserve directives" time="0" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes type" name="Should merge GraphQL Types and merge directives" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes type" name="Should merge GraphQL Types and merge directives (reversed)" time="0" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes type" name="Should merge GraphQL Types that extends the different interfaces" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes type" name="Should merge two GraphQL Types correctly when they have a conflict" time="0.018" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes enum" name="should merge different enums values" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes enum" name="should merge different same values" time="0" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes enum" name="should merge directives correctly" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes enum" name="should merge directives correctly when only one defined" time="0" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes union" name="should merge unions possible types" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes scalar" name="should merge scalar with the same type" time="0" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes input" name="should merge input" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes input" name="should merge input and prefer NonNullable over Nullable" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes schema" name="should merge Query type correctly" time="0.003" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
    <testcase classname="Merge Nodes schema" name="should remove schema definition" time="0.001" file="tests/epoxy/merge-nodes.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="Merge TypeDefs" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:17" time="0.568" tests="47">
    <testcase classname="Merge TypeDefs AST Schema Fixing" name="Should handle correctly schema without valid root AST node" time="0.015" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs AST Schema Fixing" name="Should handle correctly schema without valid types AST nodes" time="0.05" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeGraphQLTypes" name="should return the correct definition of Schema" time="0.018" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeGraphQLTypes" name="should return the correct definition of Schema" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeGraphQLTypes" name="should accept root schema object" time="0.002" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeGraphQLTypes" name="should return the correct definition of Schema when it defined multiple times" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should return a Document with the correct values" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should skip printing schema definition object on session" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should keep scalars" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should merge descriptions" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should merge everything correctly" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should include directives" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should append and extend directives" time="0.017" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should fail if inputs of the same directive are different from each other" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should merge the same directives" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="stacks all directives on fields" time="0.002" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should merge two GraphQLSchema with directives correctly" time="0.003" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should merge when directive uses enum" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should merge the same directives and its locations" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs mergeTypeDefs" name="should merge arguments" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should handle string correctly" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should handle compiled gql correctly" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should handle compiled gql and strings correctly" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should handle GraphQLSchema correctly" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should merge GraphQL Schemas that have schema definition" time="0.01" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should handle all merged correctly" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should allow GraphQLSchema with empty Query" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should allow GraphQLSchema with empty Query" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should handle extend types" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should handle extend types when GraphQLSchema is the source" time="0.003" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should handle extend input typee" time="0.002" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should fail when a field is already defined and has a different type" time="0.036" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should preserve an extend keyword if there is no base" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should merge unions correctly" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should merge unions correctly without extend" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should handle extend inputs" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should extend extension types" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs input arguments" name="should extend extension input types" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs comments" name="includes mutationType" time="0.005" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs comments" name="includes first product ENUM type" time="0.002" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs comments" name="preserves the field comments" time="0.022" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs comments" name="preserves the type comments" time="0.002" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs comments" name="preserves the input field comments" time="0.007" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs comments" name="supports already parsed documents" time="0.036" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs" name="supports already parsed documents" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs" name="excludes fields" time="0.001" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
    <testcase classname="Merge TypeDefs" name="excludes types" time="0" file="tests/epoxy/merge-typedefs.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="Merge Schemas" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:17" time="0.58" tests="9">
    <testcase classname="Merge Schemas" name="should merge two valid executable schemas" time="0.046" file="tests/epoxy/merge-schemas.spec.ts">
    </testcase>
    <testcase classname="Merge Schemas" name="should merge two valid executable schemas async" time="0.01" file="tests/epoxy/merge-schemas.spec.ts">
    </testcase>
    <testcase classname="Merge Schemas" name="should merge two valid executable schemas with extra resolvers" time="0.002" file="tests/epoxy/merge-schemas.spec.ts">
    </testcase>
    <testcase classname="Merge Schemas" name="should merge two valid executable schemas with extra typeDefs and resolvers" time="0.003" file="tests/epoxy/merge-schemas.spec.ts">
    </testcase>
    <testcase classname="Merge Schemas" name="should merge two valid schemas by keeping their directives to be used in extra typeDefs" time="0.003" file="tests/epoxy/merge-schemas.spec.ts">
    </testcase>
    <testcase classname="Merge Schemas" name="should merge valid schemas with interfaces correctly" time="0.029" file="tests/epoxy/merge-schemas.spec.ts">
    </testcase>
    <testcase classname="Merge Schemas" name="should merge scalars (part of resolvers)" time="0.004" file="tests/epoxy/merge-schemas.spec.ts">
    </testcase>
    <testcase classname="Merge Schemas" name="should merge when directive uses enum" time="0.005" file="tests/epoxy/merge-schemas.spec.ts">
    </testcase>
    <testcase classname="Merge Schemas" name="should merge a lot of directives but without high memory usage" time="0.23" file="tests/epoxy/merge-schemas.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="loadSchema" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:16" time="1.951" tests="3">
    <testcase classname="loadSchema" name="should throw when all files are invalid and unable to load it" time="0.545" file="tests/loaders/schema/integration.spec.ts">
    </testcase>
    <testcase classname="loadSchema" name="should work with ts files and without globs correctly" time="0.149" file="tests/loaders/schema/integration.spec.ts">
    </testcase>
    <testcase classname="loadSchema" name="should work with graphql single file" time="0.001" file="tests/loaders/schema/integration.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="loadFromCodeFile" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:17" time="0.466" tests="1">
    <testcase classname="loadFromCodeFile" name="Should throw an error when a document is loaded using AST and the document is not valid" time="0.254" file="tests/loaders/documents/load-from-code-file.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="schema from typedefs" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:16" time="2.044" tests="7">
    <testcase classname="schema from typedefs" name="should work with glob correctly" time="0.046" file="tests/loaders/schema/schema-from-typedefs.spec.ts">
    </testcase>
    <testcase classname="schema from typedefs" name="should ignore empty files when using glob expressions" time="0.012" file="tests/loaders/schema/schema-from-typedefs.spec.ts">
    </testcase>
    <testcase classname="schema from typedefs" name="should point to a broken file with parsing error message" time="0.01" file="tests/loaders/schema/schema-from-typedefs.spec.ts">
    </testcase>
    <testcase classname="schema from typedefs" name="should ignore graphql documents when loading a scehma" time="0.003" file="tests/loaders/schema/schema-from-typedefs.spec.ts">
    </testcase>
    <testcase classname="schema from typedefs" name="should work with graphql-tag" time="0.704" file="tests/loaders/schema/schema-from-typedefs.spec.ts">
    </testcase>
    <testcase classname="schema from typedefs" name="should work without globs correctly" time="0.006" file="tests/loaders/schema/schema-from-typedefs.spec.ts">
    </testcase>
    <testcase classname="schema from typedefs" name="should work with import notations" time="0.001" file="tests/loaders/schema/schema-from-typedefs.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="getFieldsWithDirectives" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:18" time="0.251" tests="11">
    <testcase classname="getFieldsWithDirectives" name="Should detect single basic directive" time="0.001" file="tests/utils/get-fields-with-directives.spec.ts">
    </testcase>
    <testcase classname="getFieldsWithDirectives" name="Should detect single basic directive in a type extension" time="0.001" file="tests/utils/get-fields-with-directives.spec.ts">
    </testcase>
    <testcase classname="getFieldsWithDirectives" name="Should parse string argument correctly" time="0" file="tests/utils/get-fields-with-directives.spec.ts">
    </testcase>
    <testcase classname="getFieldsWithDirectives" name="Should parse multiple arguments correctly" time="0.006" file="tests/utils/get-fields-with-directives.spec.ts">
    </testcase>
    <testcase classname="getFieldsWithDirectives" name="Should parse object arg correctly" time="0.001" file="tests/utils/get-fields-with-directives.spec.ts">
    </testcase>
    <testcase classname="getFieldsWithDirectives" name="Should parse array arg correctly" time="0" file="tests/utils/get-fields-with-directives.spec.ts">
    </testcase>
    <testcase classname="getFieldsWithDirectives" name="Should parse complex array arg correctly" time="0.001" file="tests/utils/get-fields-with-directives.spec.ts">
    </testcase>
    <testcase classname="getFieldsWithDirectives" name="Should detect multiple directives" time="0" file="tests/utils/get-fields-with-directives.spec.ts">
    </testcase>
    <testcase classname="getFieldsWithDirectives" name="Should detect multiple directives and multiple fields" time="0" file="tests/utils/get-fields-with-directives.spec.ts">
    </testcase>
    <testcase classname="getFieldsWithDirectives" name="Should detect multiple types" time="0.001" file="tests/utils/get-fields-with-directives.spec.ts">
    </testcase>
    <testcase classname="getFieldsWithDirectives" name="Should include only fields with directives" time="0" file="tests/utils/get-fields-with-directives.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="printSchemaWithDirectives" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:18" time="0.282" tests="2">
    <testcase classname="printSchemaWithDirectives" name="Should print with directives, while printSchema doesnt" time="0.048" file="tests/utils/print-schema-with-directives.spec.ts">
    </testcase>
    <testcase classname="printSchemaWithDirectives" name="Should print types correctly if they dont have astNode" time="0.002" file="tests/utils/print-schema-with-directives.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="getDirectives" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:18" time="0.244" tests="5">
    <testcase classname="getDirectives" name="should return the correct directives map when no directives specified" time="0.003" file="tests/utils/get-directives.spec.ts">
    </testcase>
    <testcase classname="getDirectives" name="should return the correct directives map when built-in directive specified over FIELD_DEFINITION" time="0.001" file="tests/utils/get-directives.spec.ts">
    </testcase>
    <testcase classname="getDirectives" name="should return the correct directives map when using custom directive without arguments" time="0.025" file="tests/utils/get-directives.spec.ts">
    </testcase>
    <testcase classname="getDirectives" name="should return the correct directives map when using custom directive with optional argument" time="0.001" file="tests/utils/get-directives.spec.ts">
    </testcase>
    <testcase classname="getDirectives" name="should return the correct directives map when using custom directive with optional argument an no value" time="0.001" file="tests/utils/get-directives.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="extractResolversFromSchema" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:18" time="0.269" tests="2">
    <testcase classname="extractResolversFromSchema" name="should extract correct resolvers from a schema with correct type mapping" time="0.01" file="tests/utils/extract-resolvers-from-schema.spec.ts">
    </testcase>
    <testcase classname="extractResolversFromSchema" name="should extract correct resolvers from a schema with selectedTypeDefs" time="0.003" file="tests/utils/extract-resolvers-from-schema.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="extractFieldResolversFromObjectType" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:18" time="0.188" tests="1">
    <testcase classname="extractFieldResolversFromObjectType" name="should extract correct resolvers from an object type" time="0.001" file="tests/utils/extract-field-resolvers-from-object-type.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:18" time="0.119" tests="1">
    <testcase classname="" name="dummy" time="0" file="tests/sonar/test-assets/11/1.spec.js">
    </testcase>
  </testsuite>
  <testsuite name="validateGraphQlDocuments" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:18" time="0.279" tests="2">
    <testcase classname="validateGraphQlDocuments" name="Should throw an informative error when validation errors happens, also check for fragments validation even why they are duplicated" time="0.016" file="tests/utils/validate-documents.spec.ts">
    </testcase>
    <testcase classname="checkValidationErrors" name="Should throw errors source files and locations" time="0.001" file="tests/utils/validate-documents.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:18" time="0.156" tests="1">
    <testcase classname="" name="dummy" time="0" file="tests/sonar/test-assets/11/1.spec.ts">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:18" time="0.098" tests="1">
    <testcase classname="" name="dummy" time="0" file="tests/sonar/test-assets/11/1.test.js">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2019-08-31T08:27:18" time="0.125" tests="1">
    <testcase classname="" name="dummy" time="0.001" file="tests/sonar/test-assets/11/2.test.ts">
    </testcase>
  </testsuite>
</testsuites>